From 39a33b481952fa2fdbbc95485895f1452d675eba Mon Sep 17 00:00:00 2001
From: Alexander Graf <agraf@suse.de>
Date: Tue, 5 Feb 2013 19:50:47 +0100
Subject: [PATCH 040/169] more work

---
 target-arm/cpu.h           |   6 +
 target-arm/helper.c        |  97 +++++++
 target-arm/helper.h        |  10 +
 target-arm/translate-a64.c | 615 ++++++++++++++++++++++++++++++++++++++-------
 4 files changed, 631 insertions(+), 97 deletions(-)

Index: qemu-1.6.0+dfsg/target-arm/cpu.h
===================================================================
--- qemu-1.6.0+dfsg.orig/target-arm/cpu.h	2013-11-05 22:23:24.135413475 +0000
+++ qemu-1.6.0+dfsg/target-arm/cpu.h	2013-11-05 22:23:24.131413485 +0000
@@ -106,6 +106,7 @@
     uint64_t xregs[32];
     uint64_t pc;
     uint64_t sp;
+    uint32_t pstate;
     /* Frequently accessed CPSR bits are stored separately for efficiency.
        This contains all the other bits.  Use cpsr_{read,write} to access
        the whole CPSR.  */
@@ -283,6 +284,11 @@
 #endif
 }
 
+#define PSTATE_N  (1 << 0)
+#define PSTATE_Z  (1 << 1)
+#define PSTATE_C  (1 << 2)
+#define PSTATE_V  (1 << 3)
+
 /* you can call this signal handler from your SIGBUS and SIGSEGV
    signal handlers to inform the virtual CPU of exceptions. non zero
    is returned if the signal was handled by the virtual CPU.  */
Index: qemu-1.6.0+dfsg/target-arm/helper.c
===================================================================
--- qemu-1.6.0+dfsg.orig/target-arm/helper.c	2013-11-05 22:23:24.135413475 +0000
+++ qemu-1.6.0+dfsg/target-arm/helper.c	2013-11-05 22:23:24.135413475 +0000
@@ -4038,3 +4038,100 @@
     float_status *fpst = fpstp;
     return float64_muladd(a, b, c, 0, fpst);
 }
+
+
+
+/************************ AArch64 ***********************/
+
+uint32_t HELPER(pstate_add)(uint32_t pstate, uint64_t a1, uint64_t a2, uint64_t ar)
+{
+    int64_t s1 = a1;
+    int64_t s2 = a2;
+    int64_t sr = ar;
+
+    pstate &= ~(PSTATE_N | PSTATE_Z | PSTATE_C | PSTATE_V);
+
+    if (sr < 0) {
+        pstate |= PSTATE_N;
+    }
+
+    if (!ar) {
+        pstate |= PSTATE_Z;
+    }
+
+    if (ar && (ar < a1)) {
+        pstate |= PSTATE_C;
+    }
+
+    if ((s1 > 0 && s2 > 0 && sr < 0) || (s1 < 0 && s2 < 0 && sr > 0)) {
+        pstate |= PSTATE_V;
+    }
+
+    return pstate;
+}
+
+uint32_t HELPER(pstate_add32)(uint32_t pstate, uint64_t x1, uint64_t x2, uint64_t xr)
+{
+    uint32_t a1 = x1;
+    uint32_t a2 = x2;
+    uint32_t ar = xr;
+
+    int32_t s1 = a1;
+    int32_t s2 = a2;
+    int32_t sr = ar;
+
+    pstate &= ~(PSTATE_N | PSTATE_Z | PSTATE_C | PSTATE_V);
+
+    if (sr < 0) {
+        pstate |= PSTATE_N;
+    }
+
+    if (!ar) {
+        pstate |= PSTATE_Z;
+    }
+
+    if (ar && (ar < a1)) {
+        pstate |= PSTATE_C;
+    }
+
+    if ((s1 > 0 && s2 > 0 && sr < 0) || (s1 < 0 && s2 < 0 && sr > 0)) {
+        pstate |= PSTATE_V;
+    }
+
+    return pstate;
+}
+
+uint32_t HELPER(pstate_addc)(uint32_t pstate, uint64_t a1, uint64_t a2, uint64_t ar)
+{
+    return helper_pstate_add(pstate, a1, a2, ar + 1);
+}
+
+uint32_t HELPER(pstate_addc32)(uint32_t pstate, uint64_t a1, uint64_t a2, uint64_t ar)
+{
+    return helper_pstate_add32(pstate, a1, a2, ar + 1);
+}
+
+uint32_t HELPER(cond)(uint32_t pstate, uint32_t cond)
+{
+    switch (cond) {
+    case 0:
+        return pstate & PSTATE_Z;
+    case 1:
+        return pstate & PSTATE_C;
+    case 2:
+        return pstate & PSTATE_N;
+    case 3:
+        return pstate & PSTATE_V;
+    case 4:
+        return (pstate & PSTATE_C) && !(pstate & PSTATE_V);
+    case 5:
+        return (((pstate & PSTATE_N) ? 1 : 0) == ((pstate & PSTATE_V) ? 1 : 0));
+    case 6:
+        return (((pstate & PSTATE_N) ? 1 : 0) == ((pstate & PSTATE_V) ? 1 : 0))
+               && !(pstate & PSTATE_Z);
+    case 7:
+    default:
+        /* ALWAYS */
+        return 1;
+    }
+}
Index: qemu-1.6.0+dfsg/target-arm/helper.h
===================================================================
--- qemu-1.6.0+dfsg.orig/target-arm/helper.h	2013-11-05 22:23:24.135413475 +0000
+++ qemu-1.6.0+dfsg/target-arm/helper.h	2013-11-05 22:23:24.135413475 +0000
@@ -458,4 +458,14 @@
 DEF_HELPER_3(neon_qzip16, void, env, i32, i32)
 DEF_HELPER_3(neon_qzip32, void, env, i32, i32)
 
+/************************ AArch64 ***********************/
+
+DEF_HELPER_FLAGS_4(pstate_add, TCG_CALL_NO_RWG_SE, i32, i32, i64, i64, i64)
+DEF_HELPER_FLAGS_4(pstate_add32, TCG_CALL_NO_RWG_SE, i32, i32, i64, i64, i64)
+DEF_HELPER_FLAGS_4(pstate_addc, TCG_CALL_NO_RWG_SE, i32, i32, i64, i64, i64)
+DEF_HELPER_FLAGS_4(pstate_addc32, TCG_CALL_NO_RWG_SE, i32, i32, i64, i64, i64)
+DEF_HELPER_FLAGS_2(cond, TCG_CALL_NO_RWG_SE, i32, i32, i32)
+
+
+
 #include "exec/def-helper.h"
Index: qemu-1.6.0+dfsg/target-arm/translate-a64.c
===================================================================
--- qemu-1.6.0+dfsg.orig/target-arm/translate-a64.c	2013-11-05 22:23:24.135413475 +0000
+++ qemu-1.6.0+dfsg/target-arm/translate-a64.c	2013-11-05 22:23:24.135413475 +0000
@@ -37,6 +37,7 @@
 static TCGv_i64 cpu_X[32];
 static TCGv_i64 cpu_pc;
 static TCGv_i64 cpu_sp;
+static TCGv_i32 pstate;
 
 static const char *regnames[] =
     { "x0", "x1", "x2", "x3", "x4", "x5", "x6", "x7",
@@ -60,6 +61,10 @@
                                           offsetof(CPUARMState, xregs[i]),
                                           regnames[i]);
     }
+
+    pstate = tcg_global_mem_new_i32(TCG_AREG0,
+                                    offsetof(CPUARMState, pstate),
+                                    "pstate");
 }
 
 void cpu_dump_state_a64(CPUARMState *env, FILE *f, fprintf_function cpu_fprintf,
@@ -75,8 +80,13 @@
         else
             cpu_fprintf(f, " ");
     }
-    cpu_fprintf(f, "XZR=%016"PRIx64, env->xregs[31]);
-    cpu_fprintf(f, "\n\n");
+    cpu_fprintf(f, "XZR=%016"PRIx64"\n", env->xregs[31]);
+    cpu_fprintf(f, "PSTATE=%c%c%c%c\n",
+        env->pstate & PSTATE_N ? 'n' : '.',
+        env->pstate & PSTATE_Z ? 'z' : '.',
+        env->pstate & PSTATE_C ? 'c' : '.',
+        env->pstate & PSTATE_V ? 'v' : '.');
+    cpu_fprintf(f, "\n");
 }
 
 static int get_bits(uint32_t inst, int start, int len)
@@ -88,7 +98,8 @@
 {
     int r = get_bits(inst, start, len);
     if (r & (1 << (len - 1))) {
-        r |= ((1ULL << (32 - len)) - 1) << len;
+        /* Extend the MSB 1 to the higher bits */
+        r |= -1 & ~((1ULL << len) - 1);
     }
     return r;
 }
@@ -98,21 +109,31 @@
     return get_bits(inst, 0, 5);
 }
 
-static void unallocated_encoding(DisasContext *s)
+static TCGv_i64 cpu_reg(int reg)
 {
-    tcg_abort();
+    if (reg == 31) {
+        /* XXX leaks temps */
+        return tcg_const_i64(0);
+    } else {
+        return cpu_X[reg];
+    }
 }
 
-static void reserved(DisasContext *s, uint32_t insn, int start, int len,
-                     uint32_t val)
+static TCGv_i64 cpu_reg_sp(int reg)
 {
-    uint32_t field = get_bits(insn, start, len);
-    if (field != val) {
-        fprintf(stderr, "Broken ins: %08x %08x %08x", insn, field, val);
-        unallocated_encoding(s);
+    if (reg == 31) {
+        return cpu_sp;
+    } else {
+        return cpu_X[reg];
     }
 }
 
+static int get_mem_index(DisasContext *s)
+{
+    /* XXX only user mode for now */
+    return 1;
+}
+
 void gen_a64_set_pc_im(uint64_t val)
 {
     tcg_gen_movi_i64(cpu_pc, val);
@@ -133,20 +154,131 @@
     s->is_jmp = DISAS_JUMP;
 }
 
-static void handle_b(CPUARMState *env, DisasContext *s, uint32_t insn)
+static void _unallocated_encoding(DisasContext *s)
+{
+    gen_exception_insn(s, 4, EXCP_UDEF);
+}
+
+#define unallocated_encoding(s) do { \
+    fprintf(stderr, "unallocated encoding at line: %d\n", __LINE__); \
+    _unallocated_encoding(s); \
+    } while(0)
+
+static void reserved(DisasContext *s, uint32_t insn, int start, int len,
+                     uint32_t val)
+{
+    uint32_t field = get_bits(insn, start, len);
+    if (field != val) {
+        fprintf(stderr, "Broken ins: %08x %08x %08x", insn, field, val);
+        unallocated_encoding(s);
+    }
+}
+
+static inline void gen_goto_tb(DisasContext *s, int n, uint64_t dest)
+{
+    TranslationBlock *tb;
+
+    tb = s->tb;
+    if ((tb->pc & TARGET_PAGE_MASK) == (dest & TARGET_PAGE_MASK)) {
+        tcg_gen_goto_tb(n);
+        gen_a64_set_pc_im(dest);
+        tcg_gen_exit_tb((tcg_target_long)tb + n);
+    } else {
+        gen_a64_set_pc_im(dest);
+        tcg_gen_exit_tb(0);
+    }
+}
+
+static void handle_b(DisasContext *s, uint32_t insn)
 {
     uint64_t addr = s->pc - 4 + (get_sbits(insn, 0, 26) << 2);
 
     if (get_bits(insn, 31, 1)) {
         /* BL */
-        tcg_gen_movi_i64(cpu_X[30], s->pc);
+        tcg_gen_movi_i64(cpu_reg(30), s->pc);
+    }
+    gen_goto_tb(s, 0, addr);
+    if (unlikely(s->singlestep_enabled)) {
+        s->is_jmp = DISAS_JUMP;
+    } else {
+        s->is_jmp = DISAS_TB_JUMP;
+    }
+}
+
+static void handle_br(DisasContext *s, uint32_t insn)
+{
+    int branch_type = get_bits(insn, 21, 2);
+    int source = get_bits(insn, 5, 5);
+
+    switch (branch_type) {
+    case 0: /* JMP */
+        break;
+    case 1: /* CALL */
+        tcg_gen_movi_i64(cpu_reg(30), s->pc);
+        break;
+    case 2: /* RET */
+        source = 30; /* XXX spec says "if absent"? */
+        break;
+    case 3:
+        unallocated_encoding(s);
+        return;
+    }
+
+    tcg_gen_mov_i64(cpu_pc, cpu_reg(source));
+    s->is_jmp = DISAS_JUMP;
+}
+
+static void handle_condb(DisasContext *s, uint32_t insn)
+{
+    uint64_t addr = s->pc - 4 + (get_sbits(insn, 0, 19) << 2);
+    int cond = get_bits(insn, 0, 4);
+    int no_match;
+    TCGv_i32 tcg_zero = tcg_const_i32(0);
+    TCGv_i32 tcg_cond = tcg_const_i32(cond);
+    TCGv_i32 tcg_condmatch = tcg_temp_new_i32();
+
+    no_match = gen_new_label();
+
+    gen_helper_cond(tcg_condmatch, pstate, tcg_cond);
+    tcg_gen_brcond_i64(TCG_COND_NE, tcg_condmatch, tcg_zero, no_match);
+
+    gen_a64_set_pc_im(addr);
+    tcg_gen_exit_tb(0);
+
+    gen_set_label(no_match);
+    gen_a64_set_pc_im(s->pc);
+
+    tcg_temp_free_i32(tcg_zero);
+    tcg_temp_free_i32(tcg_cond);
+    tcg_temp_free_i32(tcg_condmatch);
+
+    s->is_jmp = DISAS_JUMP;
+}
+
+static void handle_cb(DisasContext *s, uint32_t insn)
+{
+    uint64_t addr = s->pc - 4 + (get_sbits(insn, 5, 19) << 2);
+    bool is_zero = get_bits(insn, 24, 1);
+    int dest = get_reg(insn);
+    int no_match;
+
+    no_match = gen_new_label();
+    if (is_zero) {
+        tcg_gen_brcond_i64(TCG_COND_NE, cpu_reg(dest), cpu_reg(31), no_match);
+    } else {
+        tcg_gen_brcond_i64(TCG_COND_EQ, cpu_reg(dest), cpu_reg(31), no_match);
     }
     gen_a64_set_pc_im(addr);
+    tcg_gen_exit_tb(0);
+
+    gen_set_label(no_match);
+    gen_a64_set_pc_im(s->pc);
+
     s->is_jmp = DISAS_JUMP;
 }
 
 /* PC relative address calculation */
-static void handle_adr(CPUARMState *env, DisasContext *s, uint32_t insn)
+static void handle_adr(DisasContext *s, uint32_t insn)
 {
     int reg = get_reg(insn);
     int is_page = get_bits(insn, 31, 1);
@@ -163,10 +295,10 @@
         imm <<= 12;
     }
 
-    tcg_gen_movi_i64(cpu_X[reg], base + imm);
+    tcg_gen_movi_i64(cpu_reg(reg), base + imm);
 }
 
-static void handle_movi(CPUARMState *env, DisasContext *s, uint32_t insn)
+static void handle_movi(DisasContext *s, uint32_t insn)
 {
     int reg = get_reg(insn);
     uint64_t imm = get_bits(insn, 5, 16);
@@ -184,22 +316,22 @@
 
     if (is_k) {
         tcg_imm = tcg_const_i64(imm);
-        tcg_gen_deposit_i64(cpu_X[reg], cpu_X[reg], tcg_imm, pos, 16);
+        tcg_gen_deposit_i64(cpu_reg(reg), cpu_reg(reg), tcg_imm, pos, 16);
         tcg_temp_free_i64(tcg_imm);
     } else {
-        tcg_gen_movi_i64(cpu_X[reg], imm);
+        tcg_gen_movi_i64(cpu_reg(reg), imm);
     }
 
     if (is_n) {
-        tcg_gen_not_i32(cpu_X[reg], cpu_X[reg]);
+        tcg_gen_not_i32(cpu_reg(reg), cpu_reg(reg));
     }
 
     if (is_32bit) {
-        tcg_gen_andi_i64(cpu_X[reg], cpu_X[reg], 0xffffffff);
+        tcg_gen_andi_i64(cpu_reg(reg), cpu_reg(reg), 0xffffffff);
     }
 }
 
-static void handle_orri(CPUARMState *env, DisasContext *s, uint32_t insn)
+static void handle_orri(DisasContext *s, uint32_t insn)
 {
     fprintf(stderr, "XXX orri\n");
     unallocated_encoding(s);
@@ -212,30 +344,30 @@
     r = tcg_temp_new_i64();
 
     if (!shift) {
-        tcg_gen_mov_i64(r, cpu_X[reg]);
+        tcg_gen_mov_i64(r, cpu_reg(reg));
         return r;
     }
 
     /* XXX carry_out */
     switch (shift_type) {
     case 0: /* LSL */
-        tcg_gen_shli_i64(r, cpu_X[reg], shift);
+        tcg_gen_shli_i64(r, cpu_reg(reg), shift);
         break;
     case 1: /* LSR */
-        tcg_gen_shri_i64(r, cpu_X[reg], shift);
+        tcg_gen_shri_i64(r, cpu_reg(reg), shift);
         break;
     case 2: /* ASR */
-        tcg_gen_sari_i64(r, cpu_X[reg], shift);
+        tcg_gen_sari_i64(r, cpu_reg(reg), shift);
         break;
     case 3:
-        tcg_gen_rotri_i64(r, cpu_X[reg], shift);
+        tcg_gen_rotri_i64(r, cpu_reg(reg), shift);
         break;
     }
 
     return r;
 }
 
-static void handle_orr(CPUARMState *env, DisasContext *s, uint32_t insn)
+static void handle_orr(DisasContext *s, uint32_t insn)
 {
     int is_32bit = !get_bits(insn, 31, 1);
     int dest = get_reg(insn);
@@ -260,7 +392,7 @@
 
     /* MOV is dest = xzr & (source & ~0) */
     if (!shift_amount && is_n && opc == 0x0 && source == 0x1f) {
-        tcg_gen_mov_i64(cpu_X[dest], cpu_X[rm]);
+        tcg_gen_mov_i64(cpu_reg_sp(dest), cpu_reg(rm));
         return;
     }
 
@@ -272,13 +404,13 @@
     switch (opc) {
     case 0x0:
     case 0x3:
-        tcg_gen_and_i64(cpu_X[dest], cpu_X[source], tcg_op2);
+        tcg_gen_and_i64(cpu_reg_sp(dest), cpu_reg(source), tcg_op2);
         break;
     case 0x1:
-        tcg_gen_or_i64(cpu_X[dest], cpu_X[source], tcg_op2);
+        tcg_gen_or_i64(cpu_reg_sp(dest), cpu_reg(source), tcg_op2);
         break;
     case 0x2:
-        tcg_gen_xor_i64(cpu_X[dest], cpu_X[source], tcg_op2);
+        tcg_gen_xor_i64(cpu_reg_sp(dest), cpu_reg(source), tcg_op2);
         break;
     }
 
@@ -290,124 +422,348 @@
     tcg_temp_free_i64(tcg_op2);
 }
 
-static void handle_stp(CPUARMState *env, DisasContext *s, uint32_t insn)
+static void handle_stp(DisasContext *s, uint32_t insn)
 {
     int rt = get_reg(insn);
     int rn = get_bits(insn, 5, 5);
     int rt2 = get_bits(insn, 10, 5);
-    int offset = get_sbits(insn, 15, 7) << 3;
+    int offset = get_sbits(insn, 15, 7) << 2;
     int is_load = get_bits(insn, 22, 1);
     int is_vector = get_bits(insn, 26, 1);
     int is_signed = get_bits(insn, 30, 1);
     int is_32bit = !get_bits(insn, 31, 1);
+    int type = !get_bits(insn, 23, 2);
     TCGv_i64 tcg_addr;
-    bool postindex = false;
+    bool postindex;
+    bool wback;
+
+    switch (type) {
+    case 0:
+        postindex = false;
+        wback = false;
+        break;
+    case 1:
+        postindex = true;
+        wback = true;
+        break;
+    case 2:
+        unallocated_encoding(s);
+        return;
+    case 3:
+        postindex = false;
+        wback = true;
+        break;
+    }
 
     if (is_signed && !is_32bit) {
         unallocated_encoding(s);
         return;
     }
 
+    switch (get_bits(insn, 23, 2)) {
+    case 1: /* STP (post-index) */
+        postindex = true;
+        wback = true;
+        break;
+    case 2: /* STP (signed offset */
+        postindex = false;
+        wback = false;
+        break;
+    case 3: /* STP (pre-index) */
+        postindex = false;
+        wback = true;
+        break;
+    default:
+        unallocated_encoding(s);
+        return;
+    }
+
     if (is_vector) {
         tcg_abort();
     }
 
-    /* XXX reserved bits */
-    /* XXX flavors */
+    if (!is_32bit) {
+        offset <<= 1;
+    }
 
     tcg_addr = tcg_temp_new_i64();
     if (rn == 31) {
         /* XXX check SP alignment */
-        tcg_gen_mov_i64(tcg_addr, cpu_sp);
-    } else {
-        tcg_gen_mov_i64(tcg_addr, cpu_X[rn]);
     }
+    tcg_gen_mov_i64(tcg_addr, cpu_reg_sp(rn));
+
     if (!postindex) {
         tcg_gen_addi_i64(tcg_addr, tcg_addr, offset);
     }
 
     if (is_load) {
         if (is_32bit) {
-            tcg_gen_qemu_ld32u(cpu_X[rt], tcg_addr, 1);
+            tcg_gen_qemu_ld32u(cpu_reg(rt), tcg_addr, get_mem_index(s));
             tcg_gen_addi_i64(tcg_addr, tcg_addr, 4);
-            tcg_gen_qemu_ld32u(cpu_X[rt2], tcg_addr, 1);
+            tcg_gen_qemu_ld32u(cpu_reg(rt2), tcg_addr, get_mem_index(s));
+            tcg_gen_addi_i64(tcg_addr, tcg_addr, -4);
         } else {
-            tcg_gen_qemu_ld64(cpu_X[rt], tcg_addr, 1);
+            tcg_gen_qemu_ld64(cpu_reg(rt), tcg_addr, get_mem_index(s));
             tcg_gen_addi_i64(tcg_addr, tcg_addr, 8);
-            tcg_gen_qemu_ld64(cpu_X[rt2], tcg_addr, 1);
+            tcg_gen_qemu_ld64(cpu_reg(rt2), tcg_addr, get_mem_index(s));
+            tcg_gen_addi_i64(tcg_addr, tcg_addr, -8);
         }
     } else {
         if (is_32bit) {
-            tcg_gen_qemu_st32(tcg_addr, cpu_X[rt], 1);
+            tcg_gen_qemu_st32(cpu_reg(rt), tcg_addr, get_mem_index(s));
             tcg_gen_addi_i64(tcg_addr, tcg_addr, 4);
-            tcg_gen_qemu_st32(tcg_addr, cpu_X[rt2], 1);
+            tcg_gen_qemu_st32(cpu_reg(rt2), tcg_addr, get_mem_index(s));
+            tcg_gen_addi_i64(tcg_addr, tcg_addr, -4);
         } else {
-            tcg_gen_qemu_st64(tcg_addr, cpu_X[rt], 1);
+            tcg_gen_qemu_st64(cpu_reg(rt), tcg_addr, get_mem_index(s));
             tcg_gen_addi_i64(tcg_addr, tcg_addr, 8);
-            tcg_gen_qemu_st64(tcg_addr, cpu_X[rt2], 1);
+            tcg_gen_qemu_st64(cpu_reg(rt2), tcg_addr, get_mem_index(s));
+            tcg_gen_addi_i64(tcg_addr, tcg_addr, -8);
+        }
+    }
+
+    if (wback) {
+        if (postindex) {
+            tcg_gen_addi_i64(tcg_addr, tcg_addr, offset);
+        }
+        tcg_gen_mov_i64(cpu_reg_sp(rn), tcg_addr);
+    }
+
+    tcg_temp_free_i64(tcg_addr);
+}
+
+static void ldst_calc_index(DisasContext *s, TCGv_i64 tcg_addr,
+                            bool is_reg_offset, int offset, int size)
+{
+    bool is_shift = get_bits(offset, 0, 1);
+    int shift = size;
+    int extsize = get_bits(offset, 1, 2);
+    int rm = get_bits(offset, 4, 5);
+    bool is_signed = get_bits(offset, 3, 1);
+
+    if (!is_reg_offset) {
+        tcg_gen_addi_i64(tcg_addr, tcg_addr, offset);
+        return;
+    }
+
+    /* offset in register */
+    if (!(extsize & 1)) {
+        unallocated_encoding(s);
+        return;
+    }
+
+    if (!is_shift) {
+        shift = 0;
+    }
+
+    if (is_signed) {
+        switch (extsize) {
+        case 0:
+            tcg_gen_ext8s_i64(tcg_addr, cpu_reg(rm));
+            break;
+        case 1:
+            tcg_gen_ext16s_i64(tcg_addr, cpu_reg(rm));
+            break;
+        case 2:
+            tcg_gen_ext32s_i64(tcg_addr, cpu_reg(rm));
+            break;
         }
+    } else {
+        switch (extsize) {
+        case 0:
+            tcg_gen_ext8u_i64(tcg_addr, cpu_reg(rm));
+            break;
+        case 1:
+            tcg_gen_ext16u_i64(tcg_addr, cpu_reg(rm));
+            break;
+        case 2:
+            tcg_gen_ext32u_i64(tcg_addr, cpu_reg(rm));
+            break;
+        }
+    }
+
+    if (shift) {
+        tcg_gen_shli_i64(tcg_addr, tcg_addr, shift);
     }
+}
+
+static void handle_literal(DisasContext *s, uint32_t insn)
+{
+    int dest = get_reg(insn);
+    int opc = get_bits(insn, 30, 2);
+    int64_t imm = get_sbits(insn, 5, 19) << 2;
+    TCGv_i64 tcg_addr;
+
+    tcg_addr = tcg_const_i64((s->pc - 4) + imm);
+
+    switch (opc) {
+    case 0:
+        tcg_gen_qemu_ld32u(cpu_reg(dest), tcg_addr, get_mem_index(s));
+        break;
+    case 1:
+        tcg_gen_qemu_ld64(cpu_reg(dest), tcg_addr, get_mem_index(s));
+        break;
+    case 2:
+        tcg_gen_qemu_ld32s(cpu_reg(dest), tcg_addr, get_mem_index(s));
+        break;
+    case 3:
+        /* prefetch */
+        break;
+    }
+
     tcg_temp_free_i64(tcg_addr);
 }
 
-static void handle_ldst(CPUARMState *env, DisasContext *s, uint32_t insn)
+static void handle_ldst(DisasContext *s, uint32_t insn)
 {
     int dest = get_reg(insn);
-    int source = get_bits(insn, 5, 5); /* XXX probably more bits */
-    int index = get_bits(insn, 12, 9);
+    int source = get_bits(insn, 5, 5);
+    int offset;
     TCGv_i64 tcg_addr;
-    bool is_relative = !((insn >> 24) & 0x1);
-    bool is_store = !(insn & 0x00400000);
+    bool is_store = !get_bits(insn, 22, 1);
+    bool opc1 = get_bits(insn, 23, 1);
+    bool is_signed = false;
+    int size = get_bits(insn, 30, 2);
+    int regsize = size;
+    bool postindex = false;
+    bool wback = get_bits(insn, 10, 1);
+    int type = get_bits(insn, 10, 2);
+    bool is_reg_offset = get_bits(insn, 21, 1);
+    bool is_imm12 = get_bits(insn, 24, 1);
 
-    /* XXX reserved bits */
-    /* XXX flavors */
-    /* XXX different bit width */
 
-    if ((insn & 0xbf000000) == 0x18000000) {
-        // XXX find pattern
-        is_store = 0;
+    if (is_imm12) {
+        /* wback, postindex and reg_offset bits are inside imm12 */
+        postindex = false;
+        wback = false;
+        is_reg_offset = false;
+    } else {
+        /* These only apply to the IMM9 variant */
+        if (is_reg_offset && type != 2) {
+            unallocated_encoding(s);
+            return;
+        }
+        /* LDR (post-index) */
+        postindex = (type == 1);
     }
 
-    if ((insn & 0xbf800000) == 0xb9000000) {
-        /* UIMM12 version */
-        index = get_bits(insn, 10, 12);
+    if (!opc1) {
+        regsize = (size == 3) ? 3 : 2;
     } else {
-        /* SIMM9 version */
-        index = get_sbits(insn, 12, 9);
+        if (size == 3) {
+            /* prefetch */
+            if (!is_store) {
+                unallocated_encoding(s);
+            }
+            return;
+        }
+        if (size == 2 && !is_store) {
+            unallocated_encoding(s);
+        }
+        is_store = false;
+        is_signed = true;
+        regsize = is_store ? 3 : 2;
     }
 
-    if (is_relative) {
-        int rel = get_bits(insn, 5, 19);
-        tcg_addr = tcg_const_i64((rel << 2) + s->pc - 4);
+    if (is_imm12) {
+        /* UIMM12 version */
+        offset = get_bits(insn, 10, 12) << size;
     } else {
-        tcg_addr = tcg_temp_new_i64();
-        tcg_gen_mov_i64(tcg_addr, cpu_X[source]);
+        /* SIMM9 version */
+        offset = get_sbits(insn, 12, 9);
     }
 
-    if (index) {
-        tcg_gen_addi_i64(tcg_addr, tcg_addr, index);
+    tcg_addr = tcg_temp_new_i64();
+
+    tcg_gen_mov_i64(tcg_addr, cpu_reg_sp(source));
+
+    if (!postindex) {
+        ldst_calc_index(s, tcg_addr, is_reg_offset, offset, size);
     }
 
     if (is_store) {
-        tcg_gen_qemu_st64(cpu_X[dest], tcg_addr, 1);
+        switch (size) {
+        case 0:
+            tcg_gen_qemu_st8(cpu_reg(dest), tcg_addr, get_mem_index(s));
+            break;
+        case 1:
+            tcg_gen_qemu_st16(cpu_reg(dest), tcg_addr, get_mem_index(s));
+            break;
+        case 2:
+            tcg_gen_qemu_st32(cpu_reg(dest), tcg_addr, get_mem_index(s));
+            break;
+        case 3:
+            tcg_gen_qemu_st64(cpu_reg(dest), tcg_addr, get_mem_index(s));
+            break;
+        }
     } else {
-        tcg_gen_qemu_ld64(cpu_X[dest], tcg_addr, 1);
+        if (is_signed) {
+            /* XXX check what impact regsize has */
+            switch (size) {
+            case 0:
+                tcg_gen_qemu_ld8s(cpu_reg(dest), tcg_addr, get_mem_index(s));
+                break;
+            case 1:
+                tcg_gen_qemu_ld16s(cpu_reg(dest), tcg_addr, get_mem_index(s));
+                break;
+            case 2:
+                tcg_gen_qemu_ld32s(cpu_reg(dest), tcg_addr, get_mem_index(s));
+                break;
+            case 3:
+                tcg_gen_qemu_ld64(cpu_reg(dest), tcg_addr, get_mem_index(s));
+                break;
+            }
+        } else {
+            switch (size) {
+            case 0:
+                tcg_gen_qemu_ld8u(cpu_reg(dest), tcg_addr, get_mem_index(s));
+                break;
+            case 1:
+                tcg_gen_qemu_ld16u(cpu_reg(dest), tcg_addr, get_mem_index(s));
+                break;
+            case 2:
+                tcg_gen_qemu_ld32u(cpu_reg(dest), tcg_addr, get_mem_index(s));
+                break;
+            case 3:
+                tcg_gen_qemu_ld64(cpu_reg(dest), tcg_addr, get_mem_index(s));
+                break;
+            }
+        }
+    }
+
+    if (postindex) {
+        ldst_calc_index(s, tcg_addr, is_reg_offset, offset, size);
+    }
+
+    if (wback) {
+        tcg_gen_mov_i64(cpu_reg_sp(source), tcg_addr);
     }
 
     tcg_temp_free_i64(tcg_addr);
 }
 
-static void handle_add(CPUARMState *env, DisasContext *s, uint32_t insn)
+static void handle_extr(DisasContext *s, uint32_t insn)
+{
+    unallocated_encoding(s);
+}
+
+static void handle_bfm(DisasContext *s, uint32_t insn)
 {
+    unallocated_encoding(s);
+}
+
+static void handle_addi(DisasContext *s, uint32_t insn)
+{
+    TCGv_i64 tcg_result = tcg_temp_new_i64();
+    TCGv_i64 tcg_imm;
     int dest = get_reg(insn);
     int source = get_bits(insn, 5, 5);
-    int is_64bit = get_bits(insn, 30, 1);
     int shift = get_bits(insn, 22, 2);
-    uint64_t imm;
+    uint64_t imm = get_bits(insn, 10, 12);
+    bool is_32bit = !get_bits(insn, 31, 1);
+    bool sub_op = get_bits(insn, 30, 1);
+    bool setflags = get_bits(insn, 29, 1);
 
-    /* XXX check reserved bits */
-
-    imm = get_bits(insn, 10, 12);
     switch (shift) {
     case 0x0:
         break;
@@ -415,17 +771,44 @@
         imm <<= 12;
         break;
     default:
-        tcg_abort();
+        unallocated_encoding(s);
     }
 
-    /* XXX check is_64bit */
-    if (is_64bit) {
+    if (sub_op) {
+        imm = -imm;
     }
 
-    tcg_gen_addi_i64(cpu_X[dest], cpu_X[source], imm);
+    tcg_imm = tcg_const_i64(imm);
+    tcg_gen_add_i64(tcg_result, cpu_reg_sp(source), tcg_imm);
+
+    if (setflags) {
+        if (sub_op) {
+            if (is_32bit) {
+                gen_helper_pstate_addc32(pstate, pstate, cpu_reg_sp(source),
+                                         tcg_imm, tcg_result);
+            } else {
+                gen_helper_pstate_addc(pstate, pstate, cpu_reg_sp(source),
+                                       tcg_imm, tcg_result);
+            }
+        } else {
+            if (is_32bit) {
+                gen_helper_pstate_add32(pstate, pstate, cpu_reg_sp(source),
+                                        tcg_imm, tcg_result);
+            } else {
+                gen_helper_pstate_add(pstate, pstate, cpu_reg_sp(source),
+                                      tcg_imm, tcg_result);
+            }
+        }
+    }
+
+    if (is_32bit) {
+        tcg_gen_ext32u_i64(cpu_reg_sp(dest), tcg_result);
+    } else {
+        tcg_gen_mov_i64(cpu_reg_sp(dest), tcg_result);
+    }
 }
 
-static void handle_svc(CPUARMState *env, DisasContext *s, uint32_t insn)
+static void handle_svc(DisasContext *s, uint32_t insn)
 {
     gen_a64_set_pc_im(s->pc);
 #define DISAS_SWI 5
@@ -439,54 +822,92 @@
     insn = arm_ldl_code(env, s->pc, s->bswap_code);
     s->pc += 4;
 
+    // XXX singlestep hack
+    gen_a64_set_pc_im(s->pc);
+    s->is_jmp = DISAS_JUMP;
+    //////////////////////
+
     printf("insn: %08x\n", insn);
 
     /* One-off branch instruction layout */
     switch ((insn & 0xfc000000) >> 26) {
     case 0x25:
     case 0x5:
-        handle_b(env, s, insn);
+        handle_b(s, insn);
         return;
+    case 0x35:
+        if ((insn & 0xff9ffc1f) == 0xd61f0000) {
+            handle_br(s, insn);
+            return;
+        }
+        break;
     }
 
     /* Typical major opcode encoding */
     switch ((insn >> 24) & 0x1f) {
     case 0x0a:
-        handle_orr(env, s, insn);
+        handle_orr(s, insn);
         break;
+    case 0x08:
     case 0x09:
         reserved(s, insn, 29, 1, 1);
-        reserved(s, insn, 23, 1, 0);
-        handle_stp(env, s, insn);
+        handle_stp(s, insn);
         break;
     case 0x0D:
         reserved(s, insn, 29, 1, 1);
-        reserved(s, insn, 23, 1, 0);
-        handle_stp(env, s, insn);
+        handle_stp(s, insn);
         break;
     case 0x10:
-        handle_adr(env, s, insn);
+        handle_adr(s, insn);
         break;
     case 0x11:
-        handle_add(env, s, insn);
+        handle_addi(s, insn);
         break;
     case 0x12:
         if (get_bits(insn, 23, 1)) {
-            handle_movi(env, s, insn);
+            handle_movi(s, insn);
         } else {
-            handle_orri(env, s, insn);
+            handle_orri(s, insn);
         }
         break;
-    case 0x14:
-        handle_svc(env, s, insn);
+    case 0x13:
+        if (get_bits(insn, 23, 1)) {
+            handle_extr(s, insn);
+        } else {
+            handle_bfm(s, insn);
+        }
         break;
+    case 0x14:
+        if (get_bits(insn, 29, 3) == 0x6 && !get_bits(insn, 2, 3)) {
+            handle_svc(s, insn);
+            break;
+        }
+        if (get_bits(insn, 29, 2) == 0x1) {
+            handle_cb(s, insn);
+            break;
+        }
+        if (get_bits(insn, 29, 3) == 0x2) {
+            handle_condb(s, insn);
+            break;
+        }
+        goto unknown_insn;
+    case 0x15:
+        if (get_bits(insn, 29, 2) == 0x1) {
+            handle_cb(s, insn);
+        }
+        goto unknown_insn;
     case 0x18:
     case 0x19:
-        handle_ldst(env, s, insn);
+        if (get_bits(insn, 29, 1)) {
+            handle_ldst(s, insn);
+        } else {
+            handle_literal(s, insn);
+        }
         break;
     default:
+unknown_insn:
         printf("unknown insn: %08x\n", insn);
-        gen_exception_insn(s, 4, EXCP_UDEF);
+        unallocated_encoding(s);
         break;
     }
 }
