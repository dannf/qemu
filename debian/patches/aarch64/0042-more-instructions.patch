From 24203514cc7aa867f3b2344dc95e394f999a1516 Mon Sep 17 00:00:00 2001
From: Alexander Graf <agraf@suse.de>
Date: Fri, 8 Feb 2013 03:54:53 +0100
Subject: [PATCH 042/169] more instructions

---
 linux-user/arm/syscall.h    |  16 +-
 linux-user/arm/target_cpu.h |   6 +-
 linux-user/cpu-uname.c      |   3 +-
 linux-user/main.c           |  18 +-
 target-arm/cpu.h            |  10 +
 target-arm/helper.c         |  72 +++-
 target-arm/helper.h         |   4 +
 target-arm/translate-a64.c  | 878 +++++++++++++++++++++++++++++++++++---------
 target-arm/translate.c      |   3 +
 9 files changed, 806 insertions(+), 204 deletions(-)

Index: qemu-1.6.0+dfsg/linux-user/arm/syscall.h
===================================================================
--- qemu-1.6.0+dfsg.orig/linux-user/arm/syscall.h	2013-11-05 22:23:24.575412336 +0000
+++ qemu-1.6.0+dfsg/linux-user/arm/syscall.h	2013-11-05 22:23:24.563412368 +0000
@@ -27,7 +27,9 @@
 #define ARM_r0		uregs[0]
 #define ARM_ORIG_r0	uregs[17]
 
-#else
+#define UNAME_MACHINE "aarch64"
+
+#else /* TARGET_ARM64 */
 
 /* this struct defines the way the registers are stored on the
    stack during a system call. */
@@ -55,8 +57,14 @@
 #define ARM_r0		uregs[0]
 #define ARM_ORIG_r0	uregs[17]
 
+#if defined(TARGET_WORDS_BIGENDIAN)
+#define UNAME_MACHINE "armv5teb"
+#else
+#define UNAME_MACHINE "armv5tel"
 #endif
 
+#endif /* TARGET_ARM64 */
+
 #define ARM_SYSCALL_BASE	0x900000
 #define ARM_THUMB_SYSCALL	0
 
@@ -67,10 +75,4 @@
 #define ARM_NR_semihosting	  0x123456
 #define ARM_NR_thumb_semihosting  0xAB
 
-#if defined(TARGET_WORDS_BIGENDIAN)
-#define UNAME_MACHINE "armv5teb"
-#else
-#define UNAME_MACHINE "armv5tel"
-#endif
-
 #define TARGET_CLONE_BACKWARDS
Index: qemu-1.6.0+dfsg/linux-user/arm/target_cpu.h
===================================================================
--- qemu-1.6.0+dfsg.orig/linux-user/arm/target_cpu.h	2013-11-05 22:23:24.575412336 +0000
+++ qemu-1.6.0+dfsg/linux-user/arm/target_cpu.h	2013-11-05 22:23:24.567412357 +0000
@@ -29,7 +29,11 @@
 
 static inline void cpu_set_tls(CPUARMState *env, target_ulong newtls)
 {
-    env->cp15.c13_tls2 = newtls;
+    if (is_a64(env)) {
+	env->sr.tpidr_el0 = newtls;
+    } else {
+	env->cp15.c13_tls2 = newtls;
+    }
 }
 
 #endif
Index: qemu-1.6.0+dfsg/linux-user/cpu-uname.c
===================================================================
--- qemu-1.6.0+dfsg.orig/linux-user/cpu-uname.c	2013-11-05 22:23:24.575412336 +0000
+++ qemu-1.6.0+dfsg/linux-user/cpu-uname.c	2013-11-05 22:23:24.567412357 +0000
@@ -30,7 +30,8 @@
  * return here */
 const char *cpu_to_uname_machine(void *cpu_env)
 {
-#ifdef TARGET_ARM
+#if defined(TARGET_ARM) && !defined(TARGET_ARM64)
+
     /* utsname machine name on linux arm is CPU arch name + endianness, e.g.
      * armv7l; to get a list of CPU arch names from the linux source, use:
      *     grep arch_name: -A1 linux/arch/arm/mm/proc-*.S
Index: qemu-1.6.0+dfsg/linux-user/main.c
===================================================================
--- qemu-1.6.0+dfsg.orig/linux-user/main.c	2013-11-05 22:23:24.575412336 +0000
+++ qemu-1.6.0+dfsg/linux-user/main.c	2013-11-05 22:23:24.567412357 +0000
@@ -747,15 +747,15 @@
         case EXCP_BKPT:
             {
 #ifdef TARGET_ARM64
-                env->regs[0] = do_syscall(env,
-                                          env->xregs[8],
-                                          env->xregs[0],
-                                          env->xregs[1],
-                                          env->xregs[2],
-                                          env->xregs[3],
-                                          env->xregs[4],
-                                          env->xregs[5],
-                                          0, 0);
+                env->xregs[0] = do_syscall(env,
+                                           env->xregs[8],
+                                           env->xregs[0],
+                                           env->xregs[1],
+                                           env->xregs[2],
+                                           env->xregs[3],
+                                           env->xregs[4],
+                                           env->xregs[5],
+                                           0, 0);
 #else
 
                 env->eabi = 1;
Index: qemu-1.6.0+dfsg/target-arm/cpu.h
===================================================================
--- qemu-1.6.0+dfsg.orig/target-arm/cpu.h	2013-11-05 22:23:24.575412336 +0000
+++ qemu-1.6.0+dfsg/target-arm/cpu.h	2013-11-05 22:23:24.567412357 +0000
@@ -102,11 +102,15 @@
 typedef struct CPUARMState {
     /* Regs for current mode.  */
     uint32_t regs[16];
+
     /* Regs for A64 mode.  */
     uint64_t xregs[32];
     uint64_t pc;
     uint64_t sp;
     uint32_t pstate;
+    /* 128-bit each */
+    float64 fregs[32 * 2];
+
     /* Frequently accessed CPSR bits are stored separately for efficiency.
        This contains all the other bits.  Use cpsr_{read,write} to access
        the whole CPSR.  */
@@ -189,6 +193,12 @@
         uint32_t c15_power_control; /* power control */
     } cp15;
 
+    /* System registers (AArch64) */
+    struct {
+        uint64_t tpidr_el0;
+        uint64_t tpidrro_el0;
+    } sr;
+
     struct {
         uint32_t other_sp;
         uint32_t vecbase;
Index: qemu-1.6.0+dfsg/target-arm/helper.c
===================================================================
--- qemu-1.6.0+dfsg.orig/target-arm/helper.c	2013-11-05 22:23:24.575412336 +0000
+++ qemu-1.6.0+dfsg/target-arm/helper.c	2013-11-05 22:23:24.567412357 +0000
@@ -4103,12 +4103,12 @@
 
 uint32_t HELPER(pstate_addc)(uint32_t pstate, uint64_t a1, uint64_t a2, uint64_t ar)
 {
-    return helper_pstate_add(pstate, a1, a2, ar + 1);
+    return helper_pstate_add(pstate, a1, a2, ar);
 }
 
 uint32_t HELPER(pstate_addc32)(uint32_t pstate, uint64_t a1, uint64_t a2, uint64_t ar)
 {
-    return helper_pstate_add32(pstate, a1, a2, ar + 1);
+    return helper_pstate_add32(pstate, a1, a2, ar);
 }
 
 uint32_t HELPER(cond)(uint32_t pstate, uint32_t cond)
@@ -4118,28 +4118,94 @@
     switch (cond >> 1) {
     case 0:
         r = pstate & PSTATE_Z;
+        break;
     case 1:
         r = pstate & PSTATE_C;
+        break;
     case 2:
         r = pstate & PSTATE_N;
+        break;
     case 3:
         r = pstate & PSTATE_V;
+        break;
     case 4:
         r = (pstate & PSTATE_C) && !(pstate & PSTATE_V);
+        break;
     case 5:
         r = (((pstate & PSTATE_N) ? 1 : 0) == ((pstate & PSTATE_V) ? 1 : 0));
+        break;
     case 6:
         r = (((pstate & PSTATE_N) ? 1 : 0) == ((pstate & PSTATE_V) ? 1 : 0))
                && !(pstate & PSTATE_Z);
+        break;
     case 7:
     default:
         /* ALWAYS */
         r = 1;
+        break;
     }
 
-    if ((cond & 0x8) && (cond != 0xf)) {
+    if ((cond & 1) && (cond != 0xf)) {
         r = !r;
     }
 
+fprintf(stderr, "cond pstate=%x r = %d\n", pstate, r);
+
     return r;
 }
+
+static int get_bits(uint32_t inst, int start, int len)
+{
+    return (inst >> start) & ((1 << len) - 1);
+}
+
+uint64_t HELPER(cinc)(uint32_t pstate, uint32_t insn, uint64_t n, uint64_t m)
+{
+    bool else_inc = get_bits(insn, 10, 1);
+    int cond = get_bits(insn, 12, 4);
+    bool else_inv = get_bits(insn, 30, 1);
+    bool is_32bit = !get_bits(insn, 31, 1);
+    uint64_t r;
+
+    if (helper_cond(pstate, cond)) {
+        r = n;
+        goto out;
+    }
+
+    r = m;
+    if (else_inv) {
+        r = ~r;
+    }
+    if (else_inc) {
+        r++;
+    }
+
+out:
+    if (is_32bit) {
+        r = (uint32_t)r;
+    }
+
+    return r;
+}
+
+void HELPER(tb_flush)(CPUARMState *env)
+{
+    tb_flush(env);
+}
+
+uint64_t HELPER(sign_extend)(uint64_t x, uint64_t is_signed, uint64_t mask)
+{
+    if (x & is_signed) {
+        x |= mask;
+    }
+
+    return x;
+}
+
+uint64_t HELPER(udiv64)(uint64_t num, uint64_t den)
+{
+    if (den == 0)
+      return 0;
+    return num / den;
+}
+
Index: qemu-1.6.0+dfsg/target-arm/helper.h
===================================================================
--- qemu-1.6.0+dfsg.orig/target-arm/helper.h	2013-11-05 22:23:24.575412336 +0000
+++ qemu-1.6.0+dfsg/target-arm/helper.h	2013-11-05 22:23:24.567412357 +0000
@@ -465,6 +465,10 @@
 DEF_HELPER_FLAGS_4(pstate_addc, TCG_CALL_NO_RWG_SE, i32, i32, i64, i64, i64)
 DEF_HELPER_FLAGS_4(pstate_addc32, TCG_CALL_NO_RWG_SE, i32, i32, i64, i64, i64)
 DEF_HELPER_FLAGS_2(cond, TCG_CALL_NO_RWG_SE, i32, i32, i32)
+DEF_HELPER_FLAGS_4(cinc, TCG_CALL_NO_RWG_SE, i64, i32, i32, i64, i64)
+DEF_HELPER_FLAGS_3(sign_extend, TCG_CALL_NO_RWG_SE, i64, i64, i64, i64)
+DEF_HELPER_FLAGS_2(udiv64, TCG_CALL_NO_RWG_SE, i64, i64, i64)
+DEF_HELPER_1(tb_flush, void, env)
 
 
 
Index: qemu-1.6.0+dfsg/target-arm/translate-a64.c
===================================================================
--- qemu-1.6.0+dfsg.orig/target-arm/translate-a64.c	2013-11-05 22:23:24.575412336 +0000
+++ qemu-1.6.0+dfsg/target-arm/translate-a64.c	2013-11-05 22:23:24.571412347 +0000
@@ -29,11 +29,14 @@
 #include "tcg-op.h"
 #include "qemu/log.h"
 #include "translate.h"
+#include "qemu/host-utils.h"
 
 #include "helper.h"
 #define GEN_HELPER 1
 #include "helper.h"
 
+#define DEBUG_SINGLESTEP 1
+
 static TCGv_i64 cpu_X[32];
 static TCGv_i64 cpu_pc;
 static TCGv_i64 cpu_sp;
@@ -141,7 +144,7 @@
 
 static void gen_exception(int excp)
 {
-    TCGv tmp = tcg_temp_new_i32();
+    TCGv_i32 tmp = tcg_temp_new_i32();
     tcg_gen_movi_i32(tmp, excp);
     gen_helper_exception(cpu_env, tmp);
     tcg_temp_free_i32(tmp);
@@ -240,7 +243,7 @@
     no_match = gen_new_label();
 
     gen_helper_cond(tcg_condmatch, pstate, tcg_cond);
-    tcg_gen_brcond_i64(TCG_COND_NE, tcg_condmatch, tcg_zero, no_match);
+    tcg_gen_brcond_i32(TCG_COND_EQ, tcg_condmatch, tcg_zero, no_match);
 
     gen_a64_set_pc_im(addr);
     tcg_gen_exit_tb(0);
@@ -257,16 +260,59 @@
 
 static void handle_cb(DisasContext *s, uint32_t insn)
 {
-    uint64_t addr = s->pc - 4 + (get_sbits(insn, 0, 19) << 2);
-    bool is_zero = get_bits(insn, 24, 1);
+    uint64_t addr = s->pc - 4 + (get_sbits(insn, 5, 19) << 2);
+    bool is_zero = !get_bits(insn, 24, 1);
+    bool is_32bit = !get_bits(insn, 31, 1);
     int dest = get_reg(insn);
     int no_match;
+    TCGv_i64 tcg_cmp, tcg_zero;
+
+    tcg_cmp = tcg_temp_new_i64();
+    tcg_zero = tcg_const_i64(0);
+
+    if (is_32bit) {
+        tcg_gen_ext32u_i64(tcg_cmp, cpu_reg(dest));
+    } else {
+        tcg_gen_mov_i64(tcg_cmp, cpu_reg(dest));
+    }
 
     no_match = gen_new_label();
     if (is_zero) {
-        tcg_gen_brcond_i64(TCG_COND_NE, cpu_reg(dest), cpu_reg(31), no_match);
+        tcg_gen_brcond_i64(TCG_COND_NE, tcg_cmp, tcg_zero, no_match);
+    } else {
+        tcg_gen_brcond_i64(TCG_COND_EQ, tcg_cmp, tcg_zero, no_match);
+    }
+    gen_a64_set_pc_im(addr);
+    tcg_gen_exit_tb(0);
+
+    gen_set_label(no_match);
+    gen_a64_set_pc_im(s->pc);
+
+    s->is_jmp = DISAS_JUMP;
+
+    tcg_temp_free_i64(tcg_cmp);
+    tcg_temp_free_i64(tcg_zero);
+}
+
+static void handle_tbz(DisasContext *s, uint32_t insn)
+{
+    uint64_t addr = s->pc - 4 + (get_sbits(insn, 5, 14) << 2);
+    bool is_one = get_bits(insn, 24, 1);
+    int shift = get_bits(insn, 19, 5);
+    int source = get_reg(insn);
+    int no_match;
+    uint64_t mask = 1ULL << shift;
+    TCGv_i64 tcg_cmp, tcg_mask;
+
+    tcg_cmp = tcg_temp_new_i64();
+    tcg_mask = tcg_const_i64(mask);
+    tcg_gen_and_i64(tcg_cmp, cpu_reg(source), tcg_mask);
+
+    no_match = gen_new_label();
+    if (is_one) {
+        tcg_gen_brcond_i64(TCG_COND_NE, tcg_cmp, tcg_mask, no_match);
     } else {
-        tcg_gen_brcond_i64(TCG_COND_EQ, cpu_reg(dest), cpu_reg(31), no_match);
+        tcg_gen_brcond_i64(TCG_COND_EQ, tcg_cmp, tcg_mask, no_match);
     }
     gen_a64_set_pc_im(addr);
     tcg_gen_exit_tb(0);
@@ -274,9 +320,40 @@
     gen_set_label(no_match);
     gen_a64_set_pc_im(s->pc);
 
+    tcg_temp_free_i64(tcg_cmp);
+    tcg_temp_free_i64(tcg_mask);
+
     s->is_jmp = DISAS_JUMP;
 }
 
+static void handle_cinc(DisasContext *s, uint32_t insn)
+{
+    int rd = get_reg(insn);
+    int rn = get_bits(insn, 5, 5);
+    int rm = get_bits(insn, 16, 5);
+    TCGv_i32 tcg_insn = tcg_const_i32(insn);
+
+    gen_helper_cinc(cpu_reg(rd), pstate, tcg_insn, cpu_reg(rn), cpu_reg(rm));
+}
+
+static void handle_mrs(DisasContext *s, uint32_t insn)
+{
+    int dest = get_reg(insn);
+    int op0 = get_bits(insn, 19, 2);
+    int op1 = get_bits(insn, 16, 3);
+    int crm = get_bits(insn, 8, 4);
+    int crn = get_bits(insn, 12, 4);
+    int op2 = get_bits(insn, 5, 3);
+
+    /* XXX what are these? */
+    if (op0 == 3 && op1 == 3 && op2 == 2 && !crm && crn == 13) {
+        tcg_gen_ld_i64(cpu_reg(dest), cpu_env, offsetof(CPUARMState, sr.tpidr_el0));
+    } else {
+        fprintf(stderr, "MRS: %d %d %d %d %d\n", op0, op1, op2, crm, crn);
+        unallocated_encoding(s);
+    }
+}
+
 /* PC relative address calculation */
 static void handle_adr(DisasContext *s, uint32_t insn)
 {
@@ -323,18 +400,130 @@
     }
 
     if (is_n) {
-        tcg_gen_not_i32(cpu_reg(reg), cpu_reg(reg));
+        tcg_gen_not_i64(cpu_reg(reg), cpu_reg(reg));
     }
 
     if (is_32bit) {
-        tcg_gen_andi_i64(cpu_reg(reg), cpu_reg(reg), 0xffffffff);
+        tcg_gen_ext32u_i64(cpu_reg(reg), cpu_reg(reg));
+    }
+}
+
+#define MASK_TMASK 0
+#define MASK_WMASK 1
+static uint64_t decode_mask(int immn, int imms, int immr, int type)
+{
+    uint64_t len, levels, s, r, mask;
+
+    len = 32 - clz32((immn << 6) | imms) - 1;
+    if (!len) {
+        /* reserved */
+        return 0;
+    }
+
+    levels = (1 << (len + 1)) - 1;
+    if ((imms & levels) == levels) {
+        /* reserved */
+        return 0;
+    }
+
+    s = imms & levels;
+    r = immr & levels;
+
+    if (type == MASK_WMASK) {
+        mask = (1 << (s + 1)) - 1;
+        mask = (mask >> r) | (mask << (64 - r));
+    } else {
+        int diff = (s - r) & ((1 << len) - 1);
+        mask = (1 << (diff + 1)) - 1;
     }
+
+    return mask;
+
+/*
+ // Compute log2 of element size
+    // 2^len must be in range [2, M]
+    len = HighestSetBit(immN:NOT(imms));
+    if len < 1 then ReservedValue();
+    assert M >= (1 << len);
+    // Determine S, R and S - R parameters
+    levels = Zeros(6 - len) : Ones(len);
+    // For logical immediates an all-ones value of S is reserved
+    // since it would generate a useless all-ones result (many times)
+    if immediate && (imms AND levels) == levels then
+        ReservedValue();
+    S = UInt(imms AND levels);
+    R = UInt(immr AND levels);
+    diff = S - R;    // 6-bit subtract with borrow
+    // From a software perspective, the remaining code is equivalant to:
+    //   esize = 1 << len;
+    //   d = UInt(diff<len-1:0>);
+    //   wmask = Replicate(ROR(Zeros(esize-(S+1)):Ones(S+1), R));
+    //   tmask = Replicate(Zeros(esize-(d+1)):Ones(d+1));
+    //   return (wmask, tmask);
+*/
+}
+
+#if 0
+static uint64_t decode_tmask(int immn, int imms, int immr)
+{
+    return decode_mask(immn, imms, immr, MASK_TMASK);
+}
+#endif
+
+static uint64_t decode_wmask(int immn, int imms, int immr)
+{
+    return decode_mask(immn, imms, immr, MASK_WMASK);
 }
 
 static void handle_orri(DisasContext *s, uint32_t insn)
 {
-    fprintf(stderr, "XXX orri\n");
-    unallocated_encoding(s);
+    int is_32bit = !get_bits(insn, 31, 1);
+    int is_n = get_bits(insn, 22, 1);
+    int opc = get_bits(insn, 29, 2);
+    int dest = get_reg(insn);
+    int source = get_bits(insn, 5, 5);
+    int imms = get_bits(insn, 10, 6);
+    int immr = get_bits(insn, 16, 6);
+    TCGv_i64 tcg_dst;
+    TCGv_i64 tcg_op2;
+    bool setflags = false;
+
+    if (is_32bit && is_n) {
+        /* reserved */
+        unallocated_encoding(s);
+    }
+
+    if (opc == 0x3) {
+        setflags = true;
+    }
+
+    if (setflags) {
+        tcg_dst = cpu_reg(dest);
+    } else {
+        tcg_dst = cpu_reg_sp(dest);
+    }
+
+    tcg_op2 = tcg_const_i64(decode_wmask(is_n, imms, immr));
+
+    switch (opc) {
+    case 0x3:
+    case 0x0:
+        tcg_gen_and_i64(tcg_dst, cpu_reg(source), tcg_op2);
+        break;
+    case 0x1:
+        tcg_gen_or_i64(tcg_dst, cpu_reg(source), tcg_op2);
+        break;
+    case 0x2:
+        tcg_gen_xor_i64(tcg_dst, cpu_reg(source), tcg_op2);
+        break;
+    }
+
+    if (setflags) {
+        // XXX
+        tcg_abort();
+    }
+
+    tcg_temp_free_i64(tcg_op2);
 }
 
 static TCGv_i64 get_shift(int reg, int shift_type, int shift)
@@ -375,24 +564,23 @@
     int rm = get_bits(insn, 16, 5);
     int shift_amount = get_sbits(insn, 10, 6);
     int is_n = !get_bits(insn, 21, 1);
-    int shift_type = !get_bits(insn, 22, 2);
-    int opc = !get_bits(insn, 22, 29);
+    int shift_type = get_bits(insn, 22, 2);
+    int opc = get_bits(insn, 29, 2);
     bool setflags = (opc == 0x3);
     TCGv_i64 tcg_op2;
 
     if (is_32bit && (shift_amount < 0)) {
         /* reserved value */
-        tcg_abort();
-    }
-
-    if (is_32bit) {
-        /* XXX handle 32 bit case */
-        tcg_abort();
+        unallocated_encoding(s);
     }
 
     /* MOV is dest = xzr & (source & ~0) */
-    if (!shift_amount && is_n && opc == 0x0 && source == 0x1f) {
-        tcg_gen_mov_i64(cpu_reg_sp(dest), cpu_reg(rm));
+    if (!shift_amount && source == 0x1f) {
+        if (is_32bit) {
+            tcg_gen_ext32u_i64(cpu_reg_sp(dest), cpu_reg(rm));
+        } else {
+            tcg_gen_mov_i64(cpu_reg_sp(dest), cpu_reg(rm));
+        }
         return;
     }
 
@@ -402,18 +590,24 @@
     }
 
     switch (opc) {
-    case 0x0:
     case 0x3:
-        tcg_gen_and_i64(cpu_reg_sp(dest), cpu_reg(source), tcg_op2);
+        setflags = true;
+        /* fall through */
+    case 0x0:
+        tcg_gen_and_i64(cpu_reg(dest), cpu_reg(source), tcg_op2);
         break;
     case 0x1:
-        tcg_gen_or_i64(cpu_reg_sp(dest), cpu_reg(source), tcg_op2);
+        tcg_gen_or_i64(cpu_reg(dest), cpu_reg(source), tcg_op2);
         break;
     case 0x2:
-        tcg_gen_xor_i64(cpu_reg_sp(dest), cpu_reg(source), tcg_op2);
+        tcg_gen_xor_i64(cpu_reg(dest), cpu_reg(source), tcg_op2);
         break;
     }
 
+    if (is_32bit) {
+        tcg_gen_ext32u_i64(cpu_reg(dest), cpu_reg(dest));
+    }
+
     if (setflags) {
         /* XXX set PSTATE.N,Z,C,V */
         tcg_abort();
@@ -422,45 +616,293 @@
     tcg_temp_free_i64(tcg_op2);
 }
 
+static void setflags_add(bool sub_op, bool is_32bit, TCGv_i64 src,
+                         TCGv_i64 op2, TCGv_i64 res)
+{
+    if (sub_op) {
+        if (is_32bit) {
+            gen_helper_pstate_addc32(pstate, pstate, src, op2, res);
+        } else {
+            gen_helper_pstate_addc(pstate, pstate, src, op2, res);
+        }
+    } else {
+        if (is_32bit) {
+            gen_helper_pstate_add32(pstate, pstate, src, op2, res);
+        } else {
+            gen_helper_pstate_add(pstate, pstate, src, op2, res);
+        }
+    }
+}
+
+static void reg_extend(TCGv_i64 tcg_offset, int option, int shift, int reg)
+{
+    int extsize = get_bits(option, 0, 2);
+    bool is_signed = get_bits(option, 2, 1);
+
+    if (is_signed) {
+        switch (extsize) {
+        case 0:
+            tcg_gen_ext8s_i64(tcg_offset, cpu_reg(reg));
+            break;
+        case 1:
+            tcg_gen_ext16s_i64(tcg_offset, cpu_reg(reg));
+            break;
+        case 2:
+            tcg_gen_ext32s_i64(tcg_offset, cpu_reg(reg));
+            break;
+        case 3:
+            tcg_gen_mov_i64(tcg_offset, cpu_reg(reg));
+            break;
+        }
+    } else {
+        switch (extsize) {
+        case 0:
+            tcg_gen_ext8u_i64(tcg_offset, cpu_reg(reg));
+            break;
+        case 1:
+            tcg_gen_ext16u_i64(tcg_offset, cpu_reg(reg));
+            break;
+        case 2:
+            tcg_gen_ext32u_i64(tcg_offset, cpu_reg(reg));
+            break;
+        case 3:
+            tcg_gen_mov_i64(tcg_offset, cpu_reg(reg));
+            break;
+        }
+    }
+
+    if (shift) {
+        tcg_gen_shli_i64(tcg_offset, tcg_offset, shift);
+    }
+}
+
+static void handle_add(DisasContext *s, uint32_t insn)
+{
+    int dest = get_reg(insn);
+    int source = get_bits(insn, 5, 5);
+    int shift_amount = get_sbits(insn, 10, 6);
+    int rm = get_bits(insn, 16, 5);
+    bool extend = get_bits(insn, 21, 1);
+    int shift_type = get_bits(insn, 22, 2);
+    bool setflags = get_bits(insn, 29, 1);
+    bool sub_op = get_bits(insn, 30, 1);
+    bool is_32bit = !get_bits(insn, 31, 1);
+    int extend_type = 0;
+    TCGv_i64 tcg_op2;
+    TCGv_i64 tcg_src, tcg_dst;
+    TCGv_i64 tcg_result = tcg_temp_new_i64();
+
+    if (extend && shift_type) {
+        unallocated_encoding(s);
+    }
+
+    tcg_src = cpu_reg(source);
+    tcg_dst = cpu_reg(dest);
+    if (extend) {
+        extend_type = get_bits(insn, 13, 3);
+        shift_amount &= 0x7;
+        if (shift_amount > 4) {
+            /* reserved value */
+            unallocated_encoding(s);
+        }
+        if (!setflags) {
+            tcg_src = cpu_reg_sp(source);
+            tcg_dst = cpu_reg_sp(dest);
+        }
+    } else {
+        if (shift_type == 3) {
+            /* reserved value */
+            unallocated_encoding(s);
+        }
+    }
+
+    if (is_32bit && (shift_amount < 0)) {
+        /* reserved value */
+        unallocated_encoding(s);
+    }
+
+    if (extend) {
+        tcg_op2 = tcg_temp_new_i64();
+        reg_extend(tcg_op2, shift_amount >> 3, shift_amount & 0x7, rm);
+    } else {
+        tcg_op2 = get_shift(rm, shift_type, shift_amount);
+    }
+
+    if (sub_op) {
+        tcg_gen_sub_i64(tcg_result, tcg_src, tcg_op2);
+    } else {
+        tcg_gen_add_i64(tcg_result, tcg_src, tcg_op2);
+    }
+
+    if (setflags) {
+        setflags_add(sub_op, is_32bit, tcg_src, tcg_op2, tcg_result);
+    }
+
+    if (is_32bit) {
+        tcg_gen_ext32u_i64(tcg_dst, tcg_result);
+    } else {
+        tcg_gen_mov_i64(tcg_dst, tcg_result);
+    }
+
+    tcg_temp_free_i64(tcg_op2);
+    tcg_temp_free_i64(tcg_result);
+}
+
+static void ldst_do_vec(DisasContext *s, int dest, TCGv_i64 tcg_addr_real,
+                        int size, bool is_store)
+{
+    TCGv_i64 tcg_tmp = tcg_temp_new_i64();
+    TCGv_i64 tcg_addr = tcg_temp_new_i64();
+    int freg_offs = offsetof(CPUARMState, fregs[0]) + dest * 2;
+
+    /* we don't want to modify the caller's tcg_addr */
+    tcg_gen_mov_i64(tcg_addr, tcg_addr_real);
+
+    if (is_store) {
+        switch (size) {
+        case 0:
+            tcg_gen_ld8u_i64(tcg_tmp, cpu_env, freg_offs);
+            tcg_gen_qemu_st8(tcg_tmp, tcg_addr, get_mem_index(s));
+            break;
+        case 1:
+            tcg_gen_ld16u_i64(tcg_tmp, cpu_env, freg_offs);
+            tcg_gen_qemu_st16(tcg_tmp, tcg_addr, get_mem_index(s));
+            break;
+        case 2:
+            tcg_gen_ld32u_i64(tcg_tmp, cpu_env, freg_offs);
+            tcg_gen_qemu_st32(tcg_tmp, tcg_addr, get_mem_index(s));
+            break;
+        case 4:
+            tcg_gen_ld_i64(tcg_tmp, cpu_env, freg_offs);
+            tcg_gen_qemu_st64(tcg_tmp, tcg_addr, get_mem_index(s));
+            freg_offs += sizeof(uint64_t);
+            tcg_gen_addi_i64(tcg_addr, tcg_addr, sizeof(uint64_t));
+            /* fall through */
+        case 3:
+            tcg_gen_ld_i64(tcg_tmp, cpu_env, freg_offs);
+            tcg_gen_qemu_st64(tcg_tmp, tcg_addr, get_mem_index(s));
+            break;
+        }
+    } else {
+        switch (size) {
+        case 0:
+            tcg_gen_qemu_ld8u(tcg_tmp, tcg_addr, get_mem_index(s));
+            tcg_gen_st8_i64(tcg_tmp, cpu_env, freg_offs);
+            break;
+        case 1:
+            tcg_gen_qemu_ld16u(tcg_tmp, tcg_addr, get_mem_index(s));
+            tcg_gen_st16_i64(tcg_tmp, cpu_env, freg_offs);
+            break;
+        case 2:
+            tcg_gen_qemu_ld32u(tcg_tmp, tcg_addr, get_mem_index(s));
+            tcg_gen_st32_i64(tcg_tmp, cpu_env, freg_offs);
+            break;
+        case 4:
+            tcg_gen_qemu_ld64(tcg_tmp, tcg_addr, get_mem_index(s));
+            tcg_gen_st_i64(tcg_tmp, cpu_env, freg_offs);
+            freg_offs += sizeof(uint64_t);
+            tcg_gen_addi_i64(tcg_addr, tcg_addr, sizeof(uint64_t));
+            /* fall through */
+        case 3:
+            tcg_gen_qemu_ld64(tcg_tmp, tcg_addr, get_mem_index(s));
+            tcg_gen_st_i64(tcg_tmp, cpu_env, freg_offs);
+            break;
+        }
+    }
+
+    tcg_temp_free(tcg_addr);
+}
+
+static void ldst_do_gpr(DisasContext *s, int dest, TCGv_i64 tcg_addr, int size,
+                        bool is_store, bool is_signed)
+{
+    if (is_store) {
+        switch (size) {
+        case 0:
+            tcg_gen_qemu_st8(cpu_reg(dest), tcg_addr, get_mem_index(s));
+            break;
+        case 1:
+            tcg_gen_qemu_st16(cpu_reg(dest), tcg_addr, get_mem_index(s));
+            break;
+        case 2:
+            tcg_gen_qemu_st32(cpu_reg(dest), tcg_addr, get_mem_index(s));
+            break;
+        case 3:
+            tcg_gen_qemu_st64(cpu_reg(dest), tcg_addr, get_mem_index(s));
+            break;
+        }
+    } else {
+        if (is_signed) {
+            /* XXX check what impact regsize has */
+            switch (size) {
+            case 0:
+                tcg_gen_qemu_ld8s(cpu_reg(dest), tcg_addr, get_mem_index(s));
+                break;
+            case 1:
+                tcg_gen_qemu_ld16s(cpu_reg(dest), tcg_addr, get_mem_index(s));
+                break;
+            case 2:
+                tcg_gen_qemu_ld32s(cpu_reg(dest), tcg_addr, get_mem_index(s));
+                break;
+            case 3:
+                tcg_gen_qemu_ld64(cpu_reg(dest), tcg_addr, get_mem_index(s));
+                break;
+            }
+        } else {
+            switch (size) {
+            case 0:
+                tcg_gen_qemu_ld8u(cpu_reg(dest), tcg_addr, get_mem_index(s));
+                break;
+            case 1:
+                tcg_gen_qemu_ld16u(cpu_reg(dest), tcg_addr, get_mem_index(s));
+                break;
+            case 2:
+                tcg_gen_qemu_ld32u(cpu_reg(dest), tcg_addr, get_mem_index(s));
+                break;
+            case 3:
+                tcg_gen_qemu_ld64(cpu_reg(dest), tcg_addr, get_mem_index(s));
+                break;
+            }
+        }
+    }
+}
+
+static void ldst_do(DisasContext *s, int dest, TCGv_i64 tcg_addr, int size,
+                    bool is_store, bool is_signed, bool is_vector)
+{
+    if (is_vector) {
+        ldst_do_vec(s, dest, tcg_addr, size, is_store);
+    } else {
+        ldst_do_gpr(s, dest, tcg_addr, size, is_store, is_signed);
+    }
+}
+
 static void handle_stp(DisasContext *s, uint32_t insn)
 {
     int rt = get_reg(insn);
     int rn = get_bits(insn, 5, 5);
     int rt2 = get_bits(insn, 10, 5);
     int offset = get_sbits(insn, 15, 7) << 2;
-    int is_load = get_bits(insn, 22, 1);
+    int is_store = !get_bits(insn, 22, 1);
     int is_vector = get_bits(insn, 26, 1);
     int is_signed = get_bits(insn, 30, 1);
     int is_32bit = !get_bits(insn, 31, 1);
-    int type = !get_bits(insn, 23, 2);
+    int type = get_bits(insn, 23, 2);
     TCGv_i64 tcg_addr;
     bool postindex;
     bool wback;
+    int size = is_32bit ? 2 : 3;
+
+    if (is_vector) {
+        size = 2 + get_bits(insn, 30, 2);
+    }
 
     switch (type) {
+    default:
     case 0:
         postindex = false;
         wback = false;
         break;
-    case 1:
-        postindex = true;
-        wback = true;
-        break;
-    case 2:
-        unallocated_encoding(s);
-        return;
-    case 3:
-        postindex = false;
-        wback = true;
-        break;
-    }
-
-    if (is_signed && !is_32bit) {
-        unallocated_encoding(s);
-        return;
-    }
-
-    switch (get_bits(insn, 23, 2)) {
     case 1: /* STP (post-index) */
         postindex = true;
         wback = true;
@@ -473,13 +915,11 @@
         postindex = false;
         wback = true;
         break;
-    default:
-        unallocated_encoding(s);
-        return;
     }
 
-    if (is_vector) {
-        tcg_abort();
+    if (is_signed && !is_32bit) {
+        unallocated_encoding(s);
+        return;
     }
 
     if (!is_32bit) {
@@ -496,31 +936,10 @@
         tcg_gen_addi_i64(tcg_addr, tcg_addr, offset);
     }
 
-    if (is_load) {
-        if (is_32bit) {
-            tcg_gen_qemu_ld32u(cpu_reg(rt), tcg_addr, get_mem_index(s));
-            tcg_gen_addi_i64(tcg_addr, tcg_addr, 4);
-            tcg_gen_qemu_ld32u(cpu_reg(rt2), tcg_addr, get_mem_index(s));
-            tcg_gen_addi_i64(tcg_addr, tcg_addr, -4);
-        } else {
-            tcg_gen_qemu_ld64(cpu_reg(rt), tcg_addr, get_mem_index(s));
-            tcg_gen_addi_i64(tcg_addr, tcg_addr, 8);
-            tcg_gen_qemu_ld64(cpu_reg(rt2), tcg_addr, get_mem_index(s));
-            tcg_gen_addi_i64(tcg_addr, tcg_addr, -8);
-        }
-    } else {
-        if (is_32bit) {
-            tcg_gen_qemu_st32(cpu_reg(rt), tcg_addr, get_mem_index(s));
-            tcg_gen_addi_i64(tcg_addr, tcg_addr, 4);
-            tcg_gen_qemu_st32(cpu_reg(rt2), tcg_addr, get_mem_index(s));
-            tcg_gen_addi_i64(tcg_addr, tcg_addr, -4);
-        } else {
-            tcg_gen_qemu_st64(cpu_reg(rt), tcg_addr, get_mem_index(s));
-            tcg_gen_addi_i64(tcg_addr, tcg_addr, 8);
-            tcg_gen_qemu_st64(cpu_reg(rt2), tcg_addr, get_mem_index(s));
-            tcg_gen_addi_i64(tcg_addr, tcg_addr, -8);
-        }
-    }
+    ldst_do(s, rt, tcg_addr, size, is_store, is_signed, is_vector);
+    tcg_gen_addi_i64(tcg_addr, tcg_addr, 1 << size);
+    ldst_do(s, rt2, tcg_addr, size, is_store, is_signed, is_vector);
+    tcg_gen_addi_i64(tcg_addr, tcg_addr, -(1 << size));
 
     if (wback) {
         if (postindex) {
@@ -532,22 +951,58 @@
     tcg_temp_free_i64(tcg_addr);
 }
 
+static void handle_ldarx(DisasContext *s, uint32_t insn)
+{
+    int rt = get_reg(insn);
+    int rn = get_bits(insn, 5, 5);
+    int rt2 = get_bits(insn, 10, 5);
+    int is_atomic = !get_bits(insn, 15, 1);
+    int rs = get_bits(insn, 16, 5);
+    int is_pair = get_bits(insn, 21, 1);
+    int is_store = !get_bits(insn, 22, 1);
+    int is_excl = get_bits(insn, 23, 1);
+    int size = get_bits(insn, 30, 2);
+    TCGv_i64 tcg_addr;
+
+    tcg_addr = tcg_temp_new_i64();
+    if (rn == 31) {
+        /* XXX check SP alignment */
+    }
+    tcg_gen_mov_i64(tcg_addr, cpu_reg_sp(rn));
+
+    if (is_atomic) {
+        /* XXX add locking */
+    }
+    if (is_excl) {
+        // XXX find what status it wants
+        tcg_gen_movi_i64(cpu_reg(rs), 0);
+    }
+
+    ldst_do_gpr(s, rt, tcg_addr, size, is_store, false);
+    if (is_pair) {
+        tcg_gen_addi_i64(tcg_addr, tcg_addr, 1 << size);
+        ldst_do_gpr(s, rt2, tcg_addr, size, is_store, false);
+    }
+
+    tcg_temp_free_i64(tcg_addr);
+}
+
 static void ldst_calc_index(DisasContext *s, TCGv_i64 tcg_addr,
                             bool is_reg_offset, int offset, int size)
 {
-    bool is_shift = get_bits(offset, 0, 1);
+    int option = get_bits(offset, 1, 3);
+    bool is_shift = (option == 3);
     int shift = size;
-    int extsize = get_bits(offset, 1, 2);
-    int rm = get_bits(offset, 4, 5);
-    bool is_signed = get_bits(offset, 3, 1);
+    int rn = get_bits(offset, 4, 5);
+    TCGv_i64 tcg_offset;
 
     if (!is_reg_offset) {
-        tcg_gen_addi_i64(tcg_addr, tcg_addr, offset);
-        return;
+        tcg_offset = tcg_const_i64(offset);
+        goto add_offset;
     }
 
     /* offset in register */
-    if (!(extsize & 1)) {
+    if (!(option & 2)) {
         unallocated_encoding(s);
         return;
     }
@@ -556,35 +1011,12 @@
         shift = 0;
     }
 
-    if (is_signed) {
-        switch (extsize) {
-        case 0:
-            tcg_gen_ext8s_i64(tcg_addr, cpu_reg(rm));
-            break;
-        case 1:
-            tcg_gen_ext16s_i64(tcg_addr, cpu_reg(rm));
-            break;
-        case 2:
-            tcg_gen_ext32s_i64(tcg_addr, cpu_reg(rm));
-            break;
-        }
-    } else {
-        switch (extsize) {
-        case 0:
-            tcg_gen_ext8u_i64(tcg_addr, cpu_reg(rm));
-            break;
-        case 1:
-            tcg_gen_ext16u_i64(tcg_addr, cpu_reg(rm));
-            break;
-        case 2:
-            tcg_gen_ext32u_i64(tcg_addr, cpu_reg(rm));
-            break;
-        }
-    }
+    tcg_offset = tcg_temp_new_i64();
+    reg_extend(tcg_offset, option, shift, rn);
 
-    if (shift) {
-        tcg_gen_shli_i64(tcg_addr, tcg_addr, shift);
-    }
+add_offset:
+    tcg_gen_add_i64(tcg_addr, tcg_addr, tcg_offset);
+    tcg_temp_free_i64(tcg_offset);
 }
 
 static void handle_literal(DisasContext *s, uint32_t insn)
@@ -630,7 +1062,7 @@
     int type = get_bits(insn, 10, 2);
     bool is_reg_offset = get_bits(insn, 21, 1);
     bool is_imm12 = get_bits(insn, 24, 1);
-
+    bool is_vector = get_bits(insn, 26, 1);
 
     if (is_imm12) {
         /* wback, postindex and reg_offset bits are inside imm12 */
@@ -647,7 +1079,13 @@
         postindex = (type == 1);
     }
 
-    if (!opc1) {
+    if (is_vector) {
+        size = (opc1 ? 0x4 : 0) | size;
+        if (size > 4) {
+            unallocated_encoding(s);
+            return;
+        }
+    } else if (!opc1) {
         regsize = (size == 3) ? 3 : 2;
     } else {
         if (size == 3) {
@@ -681,55 +1119,7 @@
         ldst_calc_index(s, tcg_addr, is_reg_offset, offset, size);
     }
 
-    if (is_store) {
-        switch (size) {
-        case 0:
-            tcg_gen_qemu_st8(cpu_reg(dest), tcg_addr, get_mem_index(s));
-            break;
-        case 1:
-            tcg_gen_qemu_st16(cpu_reg(dest), tcg_addr, get_mem_index(s));
-            break;
-        case 2:
-            tcg_gen_qemu_st32(cpu_reg(dest), tcg_addr, get_mem_index(s));
-            break;
-        case 3:
-            tcg_gen_qemu_st64(cpu_reg(dest), tcg_addr, get_mem_index(s));
-            break;
-        }
-    } else {
-        if (is_signed) {
-            /* XXX check what impact regsize has */
-            switch (size) {
-            case 0:
-                tcg_gen_qemu_ld8s(cpu_reg(dest), tcg_addr, get_mem_index(s));
-                break;
-            case 1:
-                tcg_gen_qemu_ld16s(cpu_reg(dest), tcg_addr, get_mem_index(s));
-                break;
-            case 2:
-                tcg_gen_qemu_ld32s(cpu_reg(dest), tcg_addr, get_mem_index(s));
-                break;
-            case 3:
-                tcg_gen_qemu_ld64(cpu_reg(dest), tcg_addr, get_mem_index(s));
-                break;
-            }
-        } else {
-            switch (size) {
-            case 0:
-                tcg_gen_qemu_ld8u(cpu_reg(dest), tcg_addr, get_mem_index(s));
-                break;
-            case 1:
-                tcg_gen_qemu_ld16u(cpu_reg(dest), tcg_addr, get_mem_index(s));
-                break;
-            case 2:
-                tcg_gen_qemu_ld32u(cpu_reg(dest), tcg_addr, get_mem_index(s));
-                break;
-            case 3:
-                tcg_gen_qemu_ld64(cpu_reg(dest), tcg_addr, get_mem_index(s));
-                break;
-            }
-        }
-    }
+    ldst_do(s, dest, tcg_addr, size, is_store, is_signed, is_vector);
 
     if (postindex) {
         ldst_calc_index(s, tcg_addr, is_reg_offset, offset, size);
@@ -742,14 +1132,115 @@
     tcg_temp_free_i64(tcg_addr);
 }
 
+static void handle_udiv(DisasContext *s, uint32_t insn)
+{
+    int rd = get_reg(insn);
+    int rn = get_bits(insn, 5, 5);
+    int rm = get_bits(insn, 16, 5);
+    bool is_signed = get_bits(insn, 10, 1);
+    bool is_32bit = get_bits(insn, 31, 1);
+
+    if (is_signed) {
+        unallocated_encoding(s);
+        return;
+    }
+
+    if (is_32bit) {
+        unallocated_encoding(s);
+        return;
+    }
+
+    gen_helper_udiv64(cpu_reg(rd), cpu_reg(rn), cpu_reg(rm));
+}
+
 static void handle_extr(DisasContext *s, uint32_t insn)
 {
     unallocated_encoding(s);
 }
 
+/* Verified against test case -agraf */
 static void handle_bfm(DisasContext *s, uint32_t insn)
 {
-    unallocated_encoding(s);
+    bool is_32bit = !get_bits(insn, 31, 1);
+    int opc = get_bits(insn, 29, 2);
+    int dest = get_reg(insn);
+    int source = get_bits(insn, 5, 5);
+    int is_n = get_bits(insn, 22, 1);
+    int imms = get_bits(insn, 10, 6);
+    int immr = get_bits(insn, 16, 6);
+    TCGv_i64 tcg_newmask;
+    uint64_t mask, tmask, topmask;
+    uint64_t signbit = 1;
+    int bitsize = is_32bit ? 32 : 64;
+
+    if (!is_32bit && !is_n) {
+        /* reserved */
+        unallocated_encoding(s);
+    }
+
+    if (is_32bit && (is_n || (immr & (1 << 5)) || imms & (1 << 5))) {
+        /* reserved */
+        unallocated_encoding(s);
+    }
+
+    tcg_newmask = tcg_temp_new_i64();
+
+    if (imms == 0x3f) {
+        tmask = mask = ~0ULL;
+    } else {
+        tmask = mask = ((1ULL << (imms + 1)) - 1);
+    }
+
+    tcg_gen_andi_i64(tcg_newmask, cpu_reg(source), mask);
+    if (imms < immr) {
+        tcg_gen_shli_i64(tcg_newmask, tcg_newmask, bitsize - immr);
+        tmask <<= bitsize - immr;
+        signbit <<= bitsize + imms - immr;
+        if (signbit == 0x8000000000000000ULL) {
+            /* Can't pad anymore - highest bit is already set */
+            topmask = 0;
+        } else {
+            topmask = ~((1ULL << (bitsize + imms - immr + 1)) - 1);
+        }
+    } else {
+        tcg_gen_shri_i64(tcg_newmask, tcg_newmask, immr);
+        tmask >>= immr;
+        signbit <<= imms - immr;
+        topmask = ~tmask;
+    }
+
+    if (is_32bit) {
+        tcg_gen_ext32u_i64(tcg_newmask, tcg_newmask);
+    }
+
+    switch (opc) {
+    case 0: { /* SBFM */
+        TCGv_i64 tcg_mask = tcg_const_i64(topmask);
+        TCGv_i64 tcg_signbit = tcg_const_i64(signbit);
+        gen_helper_sign_extend(cpu_reg(dest), tcg_newmask, tcg_signbit,
+                               tcg_mask);
+        tcg_temp_free_i64(tcg_mask);
+        tcg_temp_free_i64(tcg_signbit);
+        break;
+    }
+    case 1: /* BFM */
+        /* replace the field inside dest */
+        tcg_gen_andi_i64(cpu_reg(dest), cpu_reg(dest), ~tmask);
+        tcg_gen_or_i64(cpu_reg(dest), cpu_reg(dest), tcg_newmask);
+        break;
+    case 2: /* UBFM */
+        tcg_gen_mov_i64(cpu_reg(dest), tcg_newmask);
+        break;
+    default:
+        unallocated_encoding(s);
+        return;
+    }
+
+    if (is_32bit) {
+        tcg_gen_ext32u_i64(cpu_reg(dest), cpu_reg(dest));
+    }
+
+    tcg_temp_free_i64(tcg_newmask);
 }
 
 static void handle_addi(DisasContext *s, uint32_t insn)
@@ -779,26 +1270,10 @@
     }
 
     tcg_imm = tcg_const_i64(imm);
-    tcg_gen_add_i64(tcg_result, cpu_reg_sp(source), tcg_imm);
+    tcg_gen_addi_i64(tcg_result, cpu_reg_sp(source), imm);
 
     if (setflags) {
-        if (sub_op) {
-            if (is_32bit) {
-                gen_helper_pstate_addc32(pstate, pstate, cpu_reg_sp(source),
-                                         tcg_imm, tcg_result);
-            } else {
-                gen_helper_pstate_addc(pstate, pstate, cpu_reg_sp(source),
-                                       tcg_imm, tcg_result);
-            }
-        } else {
-            if (is_32bit) {
-                gen_helper_pstate_add32(pstate, pstate, cpu_reg_sp(source),
-                                        tcg_imm, tcg_result);
-            } else {
-                gen_helper_pstate_add(pstate, pstate, cpu_reg_sp(source),
-                                      tcg_imm, tcg_result);
-            }
-        }
+        setflags_add(sub_op, is_32bit, cpu_reg_sp(source), tcg_imm, tcg_result);
         if (is_32bit) {
             tcg_gen_ext32u_i64(cpu_reg(dest), tcg_result);
         } else {
@@ -828,12 +1303,14 @@
     insn = arm_ldl_code(env, s->pc, s->bswap_code);
     s->pc += 4;
 
+#ifdef DEBUG_SINGLESTEP
     // XXX singlestep hack
     gen_a64_set_pc_im(s->pc);
     s->is_jmp = DISAS_JUMP;
     //////////////////////
+#endif
 
-    printf("insn: %08x\n", insn);
+    fprintf(stderr, "insn: %08x\n", insn);
 
     /* One-off branch instruction layout */
     switch ((insn & 0xfc000000) >> 26) {
@@ -854,10 +1331,16 @@
     case 0x0a:
         handle_orr(s, insn);
         break;
+    case 0x0b:
+        handle_add(s, insn);
+        break;
     case 0x08:
     case 0x09:
-        reserved(s, insn, 29, 1, 1);
-        handle_stp(s, insn);
+        if (get_bits(insn, 29, 1)) {
+            handle_stp(s, insn);
+        } else {
+            handle_ldarx(s, insn);
+        }
         break;
     case 0x0D:
         reserved(s, insn, 29, 1, 1);
@@ -900,20 +1383,49 @@
     case 0x15:
         if (get_bits(insn, 29, 2) == 0x1) {
             handle_cb(s, insn);
+            break;
+        }
+        if (get_bits(insn, 20, 12) == 0xd53) {
+            handle_mrs(s, insn);
+            break;
+        }
+        goto unknown_insn;
+    case 0x16:
+    case 0x17:
+        if (get_bits(insn, 29, 2) == 0x1) {
+            handle_tbz(s, insn);
+            break;
         }
         goto unknown_insn;
     case 0x18:
     case 0x19:
+    case 0x1c:
+    case 0x1d:
         if (get_bits(insn, 29, 1)) {
             handle_ldst(s, insn);
         } else {
             handle_literal(s, insn);
         }
         break;
+    case 0x1a:
+        if ((insn & 0x3fe00800) == 0x1a800000) {
+            handle_cinc(s, insn);
+            break;
+        } else if ((insn & 0x7fe0f800) == 0x1ac00800) {
+            handle_udiv(s, insn);
+        } else {
+            goto unknown_insn;
+        }
+        break;
     default:
 unknown_insn:
         printf("unknown insn: %08x\n", insn);
         unallocated_encoding(s);
         break;
     }
+
+#if 1 //def DEBUG_SINGLESTEP
+    if (s->is_jmp)
+        gen_helper_tb_flush(cpu_env);
+#endif
 }
Index: qemu-1.6.0+dfsg/target-arm/translate.c
===================================================================
--- qemu-1.6.0+dfsg.orig/target-arm/translate.c	2013-11-05 22:23:24.575412336 +0000
+++ qemu-1.6.0+dfsg/target-arm/translate.c	2013-11-05 22:23:24.571412347 +0000
@@ -10152,6 +10152,9 @@
         gen_set_condexec(dc);
         switch(dc->is_jmp) {
         case DISAS_NEXT:
+            if (is_a64(env)) {
+                gen_a64_set_pc_im(dc->pc);
+            }
             gen_goto_tb(dc, 1, dc->pc);
             break;
         default:
