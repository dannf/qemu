From 568d2f85337f1782282d58329fe9b322a4e6e1e6 Mon Sep 17 00:00:00 2001
From: Alexander Graf <agraf@suse.de>
Date: Sat, 9 Feb 2013 01:43:59 +0100
Subject: [PATCH 045/169] fix some issues, add msr

---
 linux-user/arm/target_signal.h |   6 +-
 target-arm/helper.c            |  45 ++++++++++--
 target-arm/helper.h            |   4 +-
 target-arm/translate-a64.c     | 161 ++++++++++++++++++++++++-----------------
 4 files changed, 141 insertions(+), 75 deletions(-)

Index: qemu-1.6.0+dfsg/linux-user/arm/target_signal.h
===================================================================
--- qemu-1.6.0+dfsg.orig/linux-user/arm/target_signal.h	2013-11-05 22:23:25.255410576 +0000
+++ qemu-1.6.0+dfsg/linux-user/arm/target_signal.h	2013-11-05 22:23:25.247410598 +0000
@@ -7,7 +7,7 @@
 
 typedef struct target_sigaltstack {
 	abi_ulong ss_sp;
-	abi_long ss_flags;
+	int ss_flags;
 	abi_ulong ss_size;
 } target_stack_t;
 
@@ -23,7 +23,11 @@
 
 static inline abi_ulong get_sp_from_cpustate(CPUARMState *state)
 {
+#ifdef TARGET_ARM64
+   return state->sp;
+#else
    return state->regs[13];
+#endif
 }
 
 #endif /* TARGET_SIGNAL_H */
Index: qemu-1.6.0+dfsg/target-arm/helper.c
===================================================================
--- qemu-1.6.0+dfsg.orig/target-arm/helper.c	2013-11-05 22:23:25.255410576 +0000
+++ qemu-1.6.0+dfsg/target-arm/helper.c	2013-11-05 22:23:25.255410576 +0000
@@ -4101,14 +4101,49 @@
     return pstate;
 }
 
-uint32_t HELPER(pstate_addc)(uint32_t pstate, uint64_t a1, uint64_t a2, uint64_t ar)
+uint32_t HELPER(pstate_sub)(uint32_t pstate, uint64_t a1, uint64_t a2, uint64_t ar)
 {
-    return helper_pstate_add(pstate, a1, a2, ar);
+    int64_t sr = ar;
+    int64_t s1 = a1;
+    int64_t s2 = a2;
+
+    pstate = helper_pstate_add(pstate, a1, a2, ar);
+
+    pstate &= ~(PSTATE_C | PSTATE_V);
+
+    if (ar && (a2 <= a1)) {
+        pstate |= PSTATE_C;
+    }
+
+    if ((s1 > 0 && s2 < 0 && sr < 0) || (s1 < 0 && s2 > 0 && sr > 0)) {
+        pstate |= PSTATE_V;
+    }
+
+    return pstate;
 }
 
-uint32_t HELPER(pstate_addc32)(uint32_t pstate, uint64_t a1, uint64_t a2, uint64_t ar)
+uint32_t HELPER(pstate_sub32)(uint32_t pstate, uint64_t x1, uint64_t x2, uint64_t xr)
 {
-    return helper_pstate_add32(pstate, a1, a2, ar);
+    uint32_t a1 = x1;
+    uint32_t a2 = x2;
+    uint32_t ar = xr;
+    int32_t sr = ar;
+    int32_t s1 = a1;
+    int32_t s2 = a2;
+
+    pstate = helper_pstate_add32(pstate, a1, a2, ar);
+
+    pstate &= ~(PSTATE_C | PSTATE_V);
+
+    if (ar && (a2 <= a1)) {
+        pstate |= PSTATE_C;
+    }
+
+    if ((s1 > 0 && s2 < 0 && sr < 0) || (s1 < 0 && s2 > 0 && sr > 0)) {
+        pstate |= PSTATE_V;
+    }
+
+    return pstate;
 }
 
 uint32_t HELPER(cond)(uint32_t pstate, uint32_t cond)
@@ -4149,7 +4184,7 @@
         r = !r;
     }
 
-fprintf(stderr, "cond pstate=%x r = %d\n", pstate, r);
+//fprintf(stderr, "cond pstate=%x r = %d\n", pstate, r);
 
     return r;
 }
Index: qemu-1.6.0+dfsg/target-arm/helper.h
===================================================================
--- qemu-1.6.0+dfsg.orig/target-arm/helper.h	2013-11-05 22:23:25.255410576 +0000
+++ qemu-1.6.0+dfsg/target-arm/helper.h	2013-11-05 22:23:25.255410576 +0000
@@ -462,8 +462,8 @@
 
 DEF_HELPER_FLAGS_4(pstate_add, TCG_CALL_NO_RWG_SE, i32, i32, i64, i64, i64)
 DEF_HELPER_FLAGS_4(pstate_add32, TCG_CALL_NO_RWG_SE, i32, i32, i64, i64, i64)
-DEF_HELPER_FLAGS_4(pstate_addc, TCG_CALL_NO_RWG_SE, i32, i32, i64, i64, i64)
-DEF_HELPER_FLAGS_4(pstate_addc32, TCG_CALL_NO_RWG_SE, i32, i32, i64, i64, i64)
+DEF_HELPER_FLAGS_4(pstate_sub, TCG_CALL_NO_RWG_SE, i32, i32, i64, i64, i64)
+DEF_HELPER_FLAGS_4(pstate_sub32, TCG_CALL_NO_RWG_SE, i32, i32, i64, i64, i64)
 DEF_HELPER_FLAGS_2(cond, TCG_CALL_NO_RWG_SE, i32, i32, i32)
 DEF_HELPER_FLAGS_4(cinc, TCG_CALL_NO_RWG_SE, i64, i32, i32, i64, i64)
 DEF_HELPER_FLAGS_3(sign_extend, TCG_CALL_NO_RWG_SE, i64, i64, i64, i64)
Index: qemu-1.6.0+dfsg/target-arm/translate-a64.c
===================================================================
--- qemu-1.6.0+dfsg.orig/target-arm/translate-a64.c	2013-11-05 22:23:25.255410576 +0000
+++ qemu-1.6.0+dfsg/target-arm/translate-a64.c	2013-11-05 22:23:25.255410576 +0000
@@ -36,6 +36,7 @@
 #include "helper.h"
 
 #define DEBUG_SINGLESTEP 1
+#define DEBUG_FLUSH 1
 
 static TCGv_i64 cpu_X[32];
 static TCGv_i64 cpu_pc;
@@ -336,6 +337,24 @@
     gen_helper_cinc(cpu_reg(rd), pstate, tcg_insn, cpu_reg(rn), cpu_reg(rm));
 }
 
+static void handle_msr(DisasContext *s, uint32_t insn)
+{
+    int dest = get_reg(insn);
+    int op0 = get_bits(insn, 19, 2);
+    int op1 = get_bits(insn, 16, 3);
+    int crm = get_bits(insn, 8, 4);
+    int crn = get_bits(insn, 12, 4);
+    int op2 = get_bits(insn, 5, 3);
+
+    /* XXX what are these? */
+    if (op0 == 3 && op1 == 3 && op2 == 2 && !crm && crn == 13) {
+        tcg_gen_st_i64(cpu_reg(dest), cpu_env, offsetof(CPUARMState, sr.tpidr_el0));
+    } else {
+        fprintf(stderr, "MSR: %d %d %d %d %d\n", op0, op1, op2, crm, crn);
+        unallocated_encoding(s);
+    }
+}
+
 static void handle_mrs(DisasContext *s, uint32_t insn)
 {
     int dest = get_reg(insn);
@@ -412,55 +431,21 @@
 #define MASK_WMASK 1
 static uint64_t decode_mask(int immn, int imms, int immr, int type)
 {
-    uint64_t len, levels, s, r, mask;
+    uint64_t mask;
+    int bitsize = immn ? 64 : 32;
 
-    len = 32 - clz32((immn << 6) | imms) - 1;
-    if (!len) {
-        /* reserved */
-        return 0;
-    }
-
-    levels = (1 << (len + 1)) - 1;
-    if ((imms & levels) == levels) {
-        /* reserved */
-        return 0;
+    if (imms == 0x3f) {
+        mask = ~0ULL;
+    } else {
+        mask = ((1ULL << (imms + 1)) - 1);
     }
+    mask = (mask >> immr) | (mask << (bitsize - immr));
 
-    s = imms & levels;
-    r = immr & levels;
-
-    if (type == MASK_WMASK) {
-        mask = (1 << (s + 1)) - 1;
-        mask = (mask >> r) | (mask << (64 - r));
-    } else {
-        int diff = (s - r) & ((1 << len) - 1);
-        mask = (1 << (diff + 1)) - 1;
+    if (type == MASK_TMASK) {
+        mask = ~mask;
     }
 
     return mask;
-
-/*
- // Compute log2 of element size
-    // 2^len must be in range [2, M]
-    len = HighestSetBit(immN:NOT(imms));
-    if len < 1 then ReservedValue();
-    assert M >= (1 << len);
-    // Determine S, R and S - R parameters
-    levels = Zeros(6 - len) : Ones(len);
-    // For logical immediates an all-ones value of S is reserved
-    // since it would generate a useless all-ones result (many times)
-    if immediate && (imms AND levels) == levels then
-        ReservedValue();
-    S = UInt(imms AND levels);
-    R = UInt(immr AND levels);
-    diff = S - R;    // 6-bit subtract with borrow
-    // From a software perspective, the remaining code is equivalant to:
-    //   esize = 1 << len;
-    //   d = UInt(diff<len-1:0>);
-    //   wmask = Replicate(ROR(Zeros(esize-(S+1)):Ones(S+1), R));
-    //   tmask = Replicate(Zeros(esize-(d+1)):Ones(d+1));
-    //   return (wmask, tmask);
-*/
 }
 
 #if 0
@@ -519,43 +504,55 @@
     }
 
     if (setflags) {
-        // XXX
-        tcg_abort();
+        gen_helper_pstate_add(pstate, pstate, tcg_dst, cpu_reg(31), tcg_dst);
     }
 
     tcg_temp_free_i64(tcg_op2);
 }
 
-static TCGv_i64 get_shift(int reg, int shift_type, int shift)
+static TCGv_i64 get_shift(int reg, int shift_type, TCGv_i64 tcg_shift)
 {
     TCGv_i64 r;
 
     r = tcg_temp_new_i64();
 
-    if (!shift) {
-        tcg_gen_mov_i64(r, cpu_reg(reg));
-        return r;
-    }
-
     /* XXX carry_out */
     switch (shift_type) {
     case 0: /* LSL */
-        tcg_gen_shli_i64(r, cpu_reg(reg), shift);
+        tcg_gen_shl_i64(r, cpu_reg(reg), tcg_shift);
         break;
     case 1: /* LSR */
-        tcg_gen_shri_i64(r, cpu_reg(reg), shift);
+        tcg_gen_shr_i64(r, cpu_reg(reg), tcg_shift);
         break;
     case 2: /* ASR */
-        tcg_gen_sari_i64(r, cpu_reg(reg), shift);
+        tcg_gen_sar_i64(r, cpu_reg(reg), tcg_shift);
         break;
     case 3:
-        tcg_gen_rotri_i64(r, cpu_reg(reg), shift);
+        tcg_gen_rotr_i64(r, cpu_reg(reg), tcg_shift);
         break;
     }
 
     return r;
 }
 
+static TCGv_i64 get_shifti(int reg, int shift_type, int shift)
+{
+    TCGv_i64 tcg_shift;
+    TCGv_i64 r;
+
+    if (!shift) {
+        r = tcg_temp_new_i64();
+        tcg_gen_mov_i64(r, cpu_reg(reg));
+        return r;
+    }
+
+    tcg_shift = tcg_const_i64(shift);
+    r = get_shift(reg, shift_type, tcg_shift);
+    tcg_temp_free_i64(tcg_shift);
+
+    return r;
+}
+
 static void handle_orr(DisasContext *s, uint32_t insn)
 {
     int is_32bit = !get_bits(insn, 31, 1);
@@ -563,7 +560,7 @@
     int source = get_bits(insn, 5, 5);
     int rm = get_bits(insn, 16, 5);
     int shift_amount = get_sbits(insn, 10, 6);
-    int is_n = !get_bits(insn, 21, 1);
+    int is_n = get_bits(insn, 21, 1);
     int shift_type = get_bits(insn, 22, 2);
     int opc = get_bits(insn, 29, 2);
     bool setflags = (opc == 0x3);
@@ -581,10 +578,13 @@
         } else {
             tcg_gen_mov_i64(cpu_reg_sp(dest), cpu_reg(rm));
         }
+        if (is_n) {
+            tcg_gen_neg_i64(cpu_reg_sp(dest), cpu_reg_sp(dest));
+        }
         return;
     }
 
-    tcg_op2 = get_shift(rm, shift_type, shift_amount);
+    tcg_op2 = get_shifti(rm, shift_type, shift_amount);
     if (is_n) {
         tcg_gen_neg_i64(tcg_op2, tcg_op2);
     }
@@ -609,8 +609,7 @@
     }
 
     if (setflags) {
-        /* XXX set PSTATE.N,Z,C,V */
-        tcg_abort();
+        gen_helper_pstate_add(pstate, pstate, cpu_reg(dest), cpu_reg(31), cpu_reg(dest));
     }
 
     tcg_temp_free_i64(tcg_op2);
@@ -621,9 +620,9 @@
 {
     if (sub_op) {
         if (is_32bit) {
-            gen_helper_pstate_addc32(pstate, pstate, src, op2, res);
+            gen_helper_pstate_sub32(pstate, pstate, src, op2, res);
         } else {
-            gen_helper_pstate_addc(pstate, pstate, src, op2, res);
+            gen_helper_pstate_sub(pstate, pstate, src, op2, res);
         }
     } else {
         if (is_32bit) {
@@ -725,7 +724,7 @@
         tcg_op2 = tcg_temp_new_i64();
         reg_extend(tcg_op2, shift_amount >> 3, shift_amount & 0x7, rm);
     } else {
-        tcg_op2 = get_shift(rm, shift_type, shift_amount);
+        tcg_op2 = get_shifti(rm, shift_type, shift_amount);
     }
 
     if (sub_op) {
@@ -960,7 +959,7 @@
     int rs = get_bits(insn, 16, 5);
     int is_pair = get_bits(insn, 21, 1);
     int is_store = !get_bits(insn, 22, 1);
-    int is_excl = get_bits(insn, 23, 1);
+    int is_excl = !get_bits(insn, 23, 1);
     int size = get_bits(insn, 30, 2);
     TCGv_i64 tcg_addr;
 
@@ -973,7 +972,7 @@
     if (is_atomic) {
         /* XXX add locking */
     }
-    if (is_excl) {
+    if (is_store && is_excl) {
         // XXX find what status it wants
         tcg_gen_movi_i64(cpu_reg(rs), 0);
     }
@@ -1132,6 +1131,24 @@
     tcg_temp_free_i64(tcg_addr);
 }
 
+static void handle_lslv(DisasContext *s, uint32_t insn)
+{
+    int rd = get_reg(insn);
+    int rn = get_bits(insn, 5, 5);
+    int rm = get_bits(insn, 16, 5);
+    int shift_type  = get_bits(insn, 10, 2);
+    bool is_32bit = !get_bits(insn, 31, 1);
+    TCGv_i64 tcg_shift;
+    TCGv_i64 tcg_shifted;
+
+    tcg_shift = tcg_temp_new_i64();
+    tcg_gen_andi_i64(tcg_shift, cpu_reg(rm), is_32bit ? 31 : 63);
+    tcg_shifted = get_shift(rn, shift_type, tcg_shift);
+    tcg_gen_mov_i64(cpu_reg(rd), tcg_shifted);
+    tcg_temp_free_i64(tcg_shift);
+    tcg_temp_free_i64(tcg_shifted);
+}
+
 static void handle_udiv(DisasContext *s, uint32_t insn)
 {
     int rd = get_reg(insn);
@@ -1293,11 +1310,12 @@
         unallocated_encoding(s);
     }
 
+    tcg_imm = tcg_const_i64(imm);
+
     if (sub_op) {
         imm = -imm;
     }
 
-    tcg_imm = tcg_const_i64(imm);
     tcg_gen_addi_i64(tcg_result, cpu_reg_sp(source), imm);
 
     if (setflags) {
@@ -1417,6 +1435,14 @@
             handle_mrs(s, insn);
             break;
         }
+        if (get_bits(insn, 20, 12) == 0xd51) {
+            handle_msr(s, insn);
+            break;
+        }
+        if ((insn & 0xfffff09f) == 0xd503309f) {
+            /* barrier instructions */
+            break;
+        }
         goto unknown_insn;
     case 0x16:
     case 0x17:
@@ -1438,9 +1464,10 @@
     case 0x1a:
         if ((insn & 0x3fe00800) == 0x1a800000) {
             handle_cinc(s, insn);
-            break;
         } else if ((insn & 0x7fe0f800) == 0x1ac00800) {
             handle_udiv(s, insn);
+        } else if ((insn & 0x7fe0f000) == 0x1ac02000) {
+            handle_lslv(s, insn);
         } else {
             goto unknown_insn;
         }
@@ -1460,7 +1487,7 @@
         break;
     }
 
-#if 1 //def DEBUG_SINGLESTEP
+#ifdef DEBUG_FLUSH
     if (s->is_jmp)
         gen_helper_tb_flush(cpu_env);
 #endif
