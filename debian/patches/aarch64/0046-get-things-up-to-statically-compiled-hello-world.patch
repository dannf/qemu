From fde0fea12687a0afd33eb7de362ce2929d5b3763 Mon Sep 17 00:00:00 2001
From: Alexander Graf <agraf@suse.de>
Date: Sat, 9 Feb 2013 04:38:25 +0100
Subject: [PATCH 046/169] get things up to statically compiled hello world

---
 target-arm/helper.c        | 16 ++++++++++++++++
 target-arm/helper.h        |  2 ++
 target-arm/translate-a64.c | 37 ++++++++++++++++++++++++++++++-------
 3 files changed, 48 insertions(+), 7 deletions(-)

Index: qemu-1.6.0+dfsg/target-arm/helper.c
===================================================================
--- qemu-1.6.0+dfsg.orig/target-arm/helper.c	2013-11-05 22:23:25.491409965 +0000
+++ qemu-1.6.0+dfsg/target-arm/helper.c	2013-11-05 22:23:25.487409975 +0000
@@ -4244,3 +4244,19 @@
     return num / den;
 }
 
+uint64_t HELPER(umulh)(uint64_t n, uint64_t m)
+{
+    uint64_t rl, rh;
+
+    mulu64(&rl, &rh, n ,m);
+    return rh;
+}
+
+uint64_t HELPER(smulh)(uint64_t n, uint64_t m)
+{
+    uint64_t rl, rh;
+
+    muls64(&rl, &rh, n ,m);
+    return rh;
+}
+
Index: qemu-1.6.0+dfsg/target-arm/helper.h
===================================================================
--- qemu-1.6.0+dfsg.orig/target-arm/helper.h	2013-11-05 22:23:25.491409965 +0000
+++ qemu-1.6.0+dfsg/target-arm/helper.h	2013-11-05 22:23:25.487409975 +0000
@@ -468,6 +468,8 @@
 DEF_HELPER_FLAGS_4(cinc, TCG_CALL_NO_RWG_SE, i64, i32, i32, i64, i64)
 DEF_HELPER_FLAGS_3(sign_extend, TCG_CALL_NO_RWG_SE, i64, i64, i64, i64)
 DEF_HELPER_FLAGS_2(udiv64, TCG_CALL_NO_RWG_SE, i64, i64, i64)
+DEF_HELPER_FLAGS_2(umulh, TCG_CALL_NO_RWG_SE, i64, i64, i64)
+DEF_HELPER_FLAGS_2(smulh, TCG_CALL_NO_RWG_SE, i64, i64, i64)
 DEF_HELPER_1(tb_flush, void, env)
 
 
Index: qemu-1.6.0+dfsg/target-arm/translate-a64.c
===================================================================
--- qemu-1.6.0+dfsg.orig/target-arm/translate-a64.c	2013-11-05 22:23:25.491409965 +0000
+++ qemu-1.6.0+dfsg/target-arm/translate-a64.c	2013-11-05 22:23:25.487409975 +0000
@@ -445,6 +445,10 @@
         mask = ~mask;
     }
 
+    if (!immn) {
+        mask = (uint32_t)mask;
+    }
+
     return mask;
 }
 
@@ -565,6 +569,7 @@
     int opc = get_bits(insn, 29, 2);
     bool setflags = (opc == 0x3);
     TCGv_i64 tcg_op2;
+    TCGv_i64 tcg_dest;
 
     if (is_32bit && (shift_amount < 0)) {
         /* reserved value */
@@ -589,27 +594,28 @@
         tcg_gen_neg_i64(tcg_op2, tcg_op2);
     }
 
+    tcg_dest = cpu_reg(dest);
     switch (opc) {
     case 0x3:
         setflags = true;
         /* fall through */
     case 0x0:
-        tcg_gen_and_i64(cpu_reg(dest), cpu_reg(source), tcg_op2);
+        tcg_gen_and_i64(tcg_dest, cpu_reg(source), tcg_op2);
         break;
     case 0x1:
-        tcg_gen_or_i64(cpu_reg(dest), cpu_reg(source), tcg_op2);
+        tcg_gen_or_i64(tcg_dest, cpu_reg(source), tcg_op2);
         break;
     case 0x2:
-        tcg_gen_xor_i64(cpu_reg(dest), cpu_reg(source), tcg_op2);
+        tcg_gen_xor_i64(tcg_dest, cpu_reg(source), tcg_op2);
         break;
     }
 
     if (is_32bit) {
-        tcg_gen_ext32u_i64(cpu_reg(dest), cpu_reg(dest));
+        tcg_gen_ext32u_i64(tcg_dest, tcg_dest);
     }
 
     if (setflags) {
-        gen_helper_pstate_add(pstate, pstate, cpu_reg(dest), cpu_reg(31), cpu_reg(dest));
+        gen_helper_pstate_add(pstate, pstate, tcg_dest, cpu_reg(31), tcg_dest);
     }
 
     tcg_temp_free_i64(tcg_op2);
@@ -990,7 +996,7 @@
                             bool is_reg_offset, int offset, int size)
 {
     int option = get_bits(offset, 1, 3);
-    bool is_shift = (option == 3);
+    bool is_shift = get_bits(offset, 0, 1) && (option == 3);
     int shift = size;
     int rn = get_bits(offset, 4, 5);
     TCGv_i64 tcg_offset;
@@ -1149,6 +1155,20 @@
     tcg_temp_free_i64(tcg_shifted);
 }
 
+static void handle_mulh(DisasContext *s, uint32_t insn)
+{
+    int rd = get_reg(insn);
+    int rn = get_bits(insn, 5, 5);
+    int rm = get_bits(insn, 16, 5);
+    bool is_signed = !get_bits(insn, 23, 1);
+
+    if (is_signed) {
+        gen_helper_smulh(cpu_reg(rd), cpu_reg(rn), cpu_reg(rm));
+    } else {
+        gen_helper_umulh(cpu_reg(rd), cpu_reg(rn), cpu_reg(rm));
+    }
+}
+
 static void handle_udiv(DisasContext *s, uint32_t insn)
 {
     int rd = get_reg(insn);
@@ -1356,7 +1376,7 @@
     //////////////////////
 #endif
 
-    fprintf(stderr, "insn: %08x\n", insn);
+//    fprintf(stderr, "insn: %08x\n", insn);
 
     /* One-off branch instruction layout */
     switch ((insn & 0xfc000000) >> 26) {
@@ -1476,6 +1496,9 @@
         if ((insn & 0x7fe00000) == 0x1b000000) {
             handle_madd(s, insn);
             break;
+        } else if ((insn & 0xff608000) == 0x9b400000) {
+            handle_mulh(s, insn);
+            break;
         } else {
             goto unknown_insn;
         }
