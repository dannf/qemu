From f7905aa1fbfe16adc1321207d4cd36f8dbac2b34 Mon Sep 17 00:00:00 2001
From: Alexander Graf <agraf@suse.de>
Date: Thu, 28 Feb 2013 03:38:17 +0100
Subject: [PATCH 089/169] implement vector orr

---
 target-arm/translate-a64.c | 68 ++++++++++++++++++++++++++++++++++++++++++++++
 1 file changed, 68 insertions(+)

Index: qemu-1.6.0+dfsg/target-arm/translate-a64.c
===================================================================
--- qemu-1.6.0+dfsg.orig/target-arm/translate-a64.c	2013-11-05 22:23:34.355387018 +0000
+++ qemu-1.6.0+dfsg/target-arm/translate-a64.c	2013-11-05 22:23:34.351387029 +0000
@@ -190,6 +190,8 @@
 
 static void _unallocated_encoding(DisasContext *s)
 {
+    fprintf(stderr, "Unknown instruction: %#x\n",
+            arm_ldl_code(current_cpu->env_ptr, s->pc - 4, s->bswap_code));
     gen_exception_insn(s, 4, EXCP_UDEF);
 }
 
@@ -2259,6 +2261,69 @@
     tcg_temp_free_i64(tcg_res);
 }
 
+/* SIMD 3 same (U=0) */
+static void handle_simd3su0(DisasContext *s, uint32_t insn)
+{
+    int rd = get_bits(insn, 0, 5);
+    int rn = get_bits(insn, 5, 5);
+    int rm = get_bits(insn, 16, 5);
+    int size = get_bits(insn, 22, 2);
+    int opcode = get_bits(insn, 11, 5);
+    bool is_q = get_bits(insn, 30, 1);
+    int freg_offs_d = offsetof(CPUARMState, vfp.regs[rd * 2]);
+    int freg_offs_n = offsetof(CPUARMState, vfp.regs[rn * 2]);
+    int freg_offs_m = offsetof(CPUARMState, vfp.regs[rm * 2]);
+    TCGv_i64 tcg_op1_1 = tcg_temp_new_i64();
+    TCGv_i64 tcg_op1_2 = tcg_temp_new_i64();
+    TCGv_i64 tcg_op2_1 = tcg_temp_new_i64();
+    TCGv_i64 tcg_op2_2 = tcg_temp_new_i64();
+    TCGv_i64 tcg_res_1 = tcg_temp_new_i64();
+    TCGv_i64 tcg_res_2 = tcg_temp_new_i64();
+
+    tcg_gen_ld_i64(tcg_op1_1, cpu_env, freg_offs_n);
+    tcg_gen_ld_i64(tcg_op2_1, cpu_env, freg_offs_m);
+    if (is_q) {
+        tcg_gen_ld_i64(tcg_op1_2, cpu_env, freg_offs_n + sizeof(float64));
+        tcg_gen_ld_i64(tcg_op2_2, cpu_env, freg_offs_m + sizeof(float64));
+    } else {
+        tcg_gen_movi_i64(tcg_op1_2, 0);
+        tcg_gen_movi_i64(tcg_op2_2, 0);
+    }
+
+    switch (opcode) {
+    case 0x3: /* ORR */
+        if (size & 1) {
+            tcg_gen_not_i64(tcg_op2_1, tcg_op2_1);
+            tcg_gen_not_i64(tcg_op2_2, tcg_op2_2);
+        }
+        if (size & 2) {
+            tcg_gen_or_i64(tcg_res_1, tcg_op1_1, tcg_op2_1);
+            tcg_gen_or_i64(tcg_res_2, tcg_op1_2, tcg_op2_2);
+        } else {
+            tcg_gen_and_i64(tcg_res_1, tcg_op1_1, tcg_op2_1);
+            tcg_gen_and_i64(tcg_res_2, tcg_op1_2, tcg_op2_2);
+        }
+        break;
+    default:
+        unallocated_encoding(s);
+        return;
+    }
+
+    clear_fpreg(rd);
+
+    tcg_gen_st_i64(tcg_res_1, cpu_env, freg_offs_d);
+    if (is_q) {
+        tcg_gen_st_i64(tcg_res_2, cpu_env, freg_offs_d + sizeof(float64));
+    }
+
+    tcg_temp_free_i64(tcg_op1_1);
+    tcg_temp_free_i64(tcg_op1_2);
+    tcg_temp_free_i64(tcg_op2_1);
+    tcg_temp_free_i64(tcg_op2_2);
+    tcg_temp_free_i64(tcg_res_1);
+    tcg_temp_free_i64(tcg_res_2);
+}
+
 static void handle_dupg(DisasContext *s, uint32_t insn)
 {
     int rd = get_bits(insn, 0, 5);
@@ -2406,6 +2471,9 @@
         } else if (!get_bits(insn, 31, 1) && !get_bits(insn, 29, 1) &&
             (get_bits(insn, 10, 6) == 0xf)) {
             handle_umov(s, insn);
+        } else if (!get_bits(insn, 31, 1) && !get_bits(insn, 29, 1) &&
+                   get_bits(insn, 21, 1) && get_bits(insn, 10, 1)) {
+            handle_simd3su0(s, insn);
         } else {
             goto unknown_insn;
         }
