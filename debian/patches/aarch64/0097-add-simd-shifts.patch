From f8bc1f0bc7269523328448ce1031d466d2192987 Mon Sep 17 00:00:00 2001
From: Alexander Graf <agraf@suse.de>
Date: Mon, 4 Mar 2013 03:31:50 +0100
Subject: [PATCH 097/169] add simd shifts

---
 target-arm/translate-a64.c | 102 +++++++++++++++++++++++++++++++++++++++++++++
 1 file changed, 102 insertions(+)

Index: qemu-1.6.0+dfsg/target-arm/translate-a64.c
===================================================================
--- qemu-1.6.0+dfsg.orig/target-arm/translate-a64.c	2013-11-05 22:23:35.995382773 +0000
+++ qemu-1.6.0+dfsg/target-arm/translate-a64.c	2013-11-05 22:23:35.995382773 +0000
@@ -2554,6 +2554,102 @@
     tcg_temp_free_i64(tcg_imm);
 }
 
+/* SIMD shift ushll */
+static void handle_ushll(DisasContext *s, uint32_t insn)
+{
+    int rd = get_bits(insn, 0, 5);
+    int rn = get_bits(insn, 5, 5);
+    int immh = get_bits(insn, 19, 4);
+    bool is_q = get_bits(insn, 30, 1);
+    int freg_offs_d = offsetof(CPUARMState, vfp.regs[rd * 2]);
+    int freg_offs_n = offsetof(CPUARMState, vfp.regs[rn * 2]);
+    TCGv_i64 tcg_tmp = tcg_temp_new_i64();
+    int i;
+    int ebytes;
+    int size;
+    int shift = get_bits(insn, 16, 7);
+
+    if (is_q) {
+        freg_offs_n += sizeof(float64);
+    }
+
+    for (size = 0; !(immh & (1 << size)); size++) {
+        if (size > 3) {
+            unallocated_encoding(s);
+            return;
+        }
+    }
+
+    ebytes = 1 << size;
+    shift -= (8 << size);
+
+    if (!immh) {
+        /* XXX see asimdimm */
+        unallocated_encoding(s);
+        return;
+    }
+
+    if (immh & 0x8) {
+        unallocated_encoding(s);
+        return;
+    }
+
+    for (i = 0; i < (8 / ebytes); i++) {
+        simd_ld(tcg_tmp, freg_offs_n + (i * ebytes), size);
+        tcg_gen_shli_i64(tcg_tmp, tcg_tmp, shift);
+        simd_st(tcg_tmp, freg_offs_d + (i * ebytes * 2), size + 1);
+    }
+
+    tcg_temp_free_i64(tcg_tmp);
+}
+
+/* SIMD shift shl */
+static void handle_simdshl(DisasContext *s, uint32_t insn)
+{
+    int rd = get_bits(insn, 0, 5);
+    int rn = get_bits(insn, 5, 5);
+    int immh = get_bits(insn, 19, 4);
+    bool is_q = get_bits(insn, 30, 1);
+    int freg_offs_d = offsetof(CPUARMState, vfp.regs[rd * 2]);
+    int freg_offs_n = offsetof(CPUARMState, vfp.regs[rn * 2]);
+    TCGv_i64 tcg_tmp = tcg_temp_new_i64();
+    int i;
+    int ebytes;
+    int size;
+    int shift = get_bits(insn, 16, 7);
+
+    size = clz32(immh) - (31 - 4);
+
+    if (size > 3) {
+        /* XXX implement 128bit operations */
+        unallocated_encoding(s);
+        return;
+    }
+
+    ebytes = 1 << size;
+    shift -= (8 << size);
+
+    if (!immh) {
+        /* XXX see asimdimm */
+        unallocated_encoding(s);
+        return;
+    }
+
+    for (i = 0; i < (16 / ebytes); i++) {
+        simd_ld(tcg_tmp, freg_offs_n + (i * ebytes), size);
+        tcg_gen_shli_i64(tcg_tmp, tcg_tmp, shift);
+        simd_st(tcg_tmp, freg_offs_d + (i * ebytes), size);
+    }
+
+    if (!is_q) {
+        TCGv_i64 tcg_zero = tcg_const_i64(0);
+        simd_st(tcg_zero, freg_offs_d + sizeof(float64), 3);
+        tcg_temp_free_i64(tcg_zero);
+    }
+
+    tcg_temp_free_i64(tcg_tmp);
+}
+
 /* SIMD load/store multiple (post-indexed) */
 static void handle_simdldstm(DisasContext *s, uint32_t insn, bool is_wback)
 {
@@ -2902,6 +2998,12 @@
         if (!get_bits(insn, 31, 1) && !get_bits(insn, 19, 5) &&
             (get_bits(insn, 10, 2) == 1)) {
             handle_simdmovi(s, insn);
+        } else if (!get_bits(insn, 31, 1) && !get_bits(insn, 23, 1) &&
+                   (get_bits(insn, 10, 6) == 0x29)) {
+            handle_ushll(s, insn);
+        } else if (!get_bits(insn, 31, 1) && !get_bits(insn, 23, 1) &&
+                   (get_bits(insn, 10, 6) == 0x15)) {
+            handle_simdshl(s, insn);
         } else {
             goto unknown_insn;
         }
