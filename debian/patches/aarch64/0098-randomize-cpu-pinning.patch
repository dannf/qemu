From dfbd91df71895660eee3bcf1299eca91429f7695 Mon Sep 17 00:00:00 2001
From: Michael Matz <matz@suse.de>
Date: Mon, 4 Mar 2013 17:46:38 +0100
Subject: [PATCH 098/169] randomize cpu pinning

---
 linux-user/signal.c  | 26 +++++++++++++++++++++++++-
 linux-user/syscall.c | 32 ++++++++++++++++++++++++++++----
 2 files changed, 53 insertions(+), 5 deletions(-)

Index: qemu-1.6.0+dfsg/linux-user/signal.c
===================================================================
--- qemu-1.6.0+dfsg.orig/linux-user/signal.c	2013-11-05 22:23:36.191382266 +0000
+++ qemu-1.6.0+dfsg/linux-user/signal.c	2013-11-05 22:23:36.187382276 +0000
@@ -653,9 +653,33 @@
              * boehm-gc.
              */
             if ((k->sa_flags & TARGET_SA_RESTART) && host_sig == SIGPWR) {
+		static int thecpu = -1;
                 cpu_set_t mask;
+		if (thecpu < 0) {
+		    /* Try to find out a randomized CPU to which to pin,
+		       so that potential parallel qemu processes don't
+		       compete for the same CPU.  Select one of the
+		       CPUs to which we're pinned already by counting
+		       them and choosing the "random"th one.  */
+		    int count, i;
+		    if (sched_getaffinity (0, sizeof(mask), &mask) < 0)
+		        thecpu = 0;
+		    else {
+			count = CPU_COUNT (&mask);
+			if (count > 1) {
+			    thecpu = getpid() % count;
+			    for (i = 0; i < CPU_SETSIZE; i++)
+			        if (CPU_ISSET (i, &mask)) {
+				    if (thecpu-- == 0)
+				        break;
+			        }
+			    thecpu = i;
+			} else
+			  thecpu = 0;
+		    }
+		}
                 CPU_ZERO(&mask);
-                CPU_SET(0, &mask);
+                CPU_SET(thecpu, &mask);
                 sched_setaffinity(0, sizeof(mask), &mask);
             }
 #else
Index: qemu-1.6.0+dfsg/linux-user/syscall.c
===================================================================
--- qemu-1.6.0+dfsg.orig/linux-user/syscall.c	2013-11-05 22:23:36.191382266 +0000
+++ qemu-1.6.0+dfsg/linux-user/syscall.c	2013-11-05 22:23:36.187382276 +0000
@@ -4339,10 +4339,34 @@
         /* agraf: Pin ourselves to a single CPU when running multi-threaded.
            This turned out to improve stability for me. */
         {
-            cpu_set_t mask;
-            CPU_ZERO(&mask);
-            CPU_SET(0, &mask);
-            sched_setaffinity(0, sizeof(mask), &mask);
+	    static int thecpu = -1;
+	    cpu_set_t mask;
+	    if (thecpu < 0) {
+		/* Try to find out a randomized CPU to which to pin,
+		   so that potential parallel qemu processes don't
+		   compete for the same CPU.  Select one of the
+		   CPUs to which we're pinned already by counting
+		   them and choosing the "random"th one.  */
+		int count, i;
+		if (sched_getaffinity (0, sizeof(mask), &mask) < 0)
+		    thecpu = 0;
+		else {
+		    count = CPU_COUNT (&mask);
+		    if (count > 1) {
+			thecpu = getpid() % count;
+			for (i = 0; i < CPU_SETSIZE; i++)
+			    if (CPU_ISSET (i, &mask)) {
+			        if (thecpu-- == 0)
+				    break;
+			    }
+			thecpu = i;
+		    } else
+		        thecpu = 0;
+		}
+	    }
+	    CPU_ZERO(&mask);
+	    CPU_SET(thecpu, &mask);
+	    sched_setaffinity(0, sizeof(mask), &mask);
         }
 
         /* Grab a mutex so that thread setup appears atomic.  */
