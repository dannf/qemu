From 7c6d5fe6e005439c9c199382e9909920c1e41d2b Mon Sep 17 00:00:00 2001
From: Michael Matz <matz@suse.de>
Date: Mon, 18 Mar 2013 03:24:52 +0100
Subject: [PATCH 103/169] Add scalar f{min,max}{,nm}.

The *nm variants are specified to change the input operands before
the normal min/max happens.  It seemed a good addition to softfloat,
so add normal softfloat routines for that, and use them in the normal
way via VFP_BINOP.
---
 target-arm/helper.c        | 46 ++++++++++++++++++++++++++++++++++++++++++++++
 target-arm/helper.h        |  8 ++++++++
 target-arm/translate-a64.c | 24 ++++++++++++++++++++++++
 3 files changed, 78 insertions(+)

Index: qemu-1.6.0+dfsg/target-arm/helper.c
===================================================================
--- qemu-1.6.0+dfsg.orig/target-arm/helper.c	2013-11-05 22:23:37.171379729 +0000
+++ qemu-1.6.0+dfsg/target-arm/helper.c	2013-11-05 22:23:37.167379740 +0000
@@ -3568,6 +3568,48 @@
     HELPER(vfp_set_fpscr)(env, val);
 }
 
+/* Some softfloat routines that are convenient.  */
+float32 float32_minnm (float32 a, float32 b, float_status *fpst);
+float32 float32_maxnm (float32 a, float32 b, float_status *fpst);
+float64 float64_minnm (float64 a, float64 b, float_status *fpst);
+float64 float64_maxnm (float64 a, float64 b, float_status *fpst);
+
+float32 float32_minnm (float32 a, float32 b, float_status *fpst)
+{
+  if (float32_is_quiet_nan (a) && !float32_is_quiet_nan (b))
+    a = float32_infinity;
+  else if (!float32_is_quiet_nan (a) && float32_is_quiet_nan (b))
+    b = float32_infinity;
+  return float32_min (a, b, fpst);
+}
+
+float32 float32_maxnm (float32 a, float32 b, float_status *fpst)
+{
+  if (float32_is_quiet_nan (a) && !float32_is_quiet_nan (b))
+    a = float32_set_sign (float32_infinity, 1);
+  else if (!float32_is_quiet_nan (a) && float32_is_quiet_nan (b))
+    b = float32_set_sign (float32_infinity, 1);
+  return float32_max (a, b, fpst);
+}
+
+float64 float64_minnm (float64 a, float64 b, float_status *fpst)
+{
+  if (float64_is_quiet_nan (a) && !float64_is_quiet_nan (b))
+    a = float64_infinity;
+  else if (!float64_is_quiet_nan (a) && float64_is_quiet_nan (b))
+    b = float64_infinity;
+  return float64_min (a, b, fpst);
+}
+
+float64 float64_maxnm (float64 a, float64 b, float_status *fpst)
+{
+  if (float64_is_quiet_nan (a) && !float64_is_quiet_nan (b))
+    a = float64_set_sign (float64_infinity, 1);
+  else if (!float64_is_quiet_nan (a) && float64_is_quiet_nan (b))
+    b = float64_set_sign (float64_infinity, 1);
+  return float64_max (a, b, fpst);
+}
+
 #define VFP_HELPER(name, p) HELPER(glue(glue(vfp_,name),p))
 
 #define VFP_BINOP(name) \
@@ -3585,6 +3627,10 @@
 VFP_BINOP(sub)
 VFP_BINOP(mul)
 VFP_BINOP(div)
+VFP_BINOP(min)
+VFP_BINOP(max)
+VFP_BINOP(minnm)
+VFP_BINOP(maxnm)
 #undef VFP_BINOP
 
 float32 VFP_HELPER(neg, s)(float32 a)
Index: qemu-1.6.0+dfsg/target-arm/helper.h
===================================================================
--- qemu-1.6.0+dfsg.orig/target-arm/helper.h	2013-11-05 22:23:37.171379729 +0000
+++ qemu-1.6.0+dfsg/target-arm/helper.h	2013-11-05 22:23:37.167379740 +0000
@@ -79,6 +79,14 @@
 DEF_HELPER_3(vfp_muld, f64, f64, f64, ptr)
 DEF_HELPER_3(vfp_divs, f32, f32, f32, ptr)
 DEF_HELPER_3(vfp_divd, f64, f64, f64, ptr)
+DEF_HELPER_3(vfp_maxs, f32, f32, f32, ptr)
+DEF_HELPER_3(vfp_maxd, f64, f64, f64, ptr)
+DEF_HELPER_3(vfp_mins, f32, f32, f32, ptr)
+DEF_HELPER_3(vfp_mind, f64, f64, f64, ptr)
+DEF_HELPER_3(vfp_maxnms, f32, f32, f32, ptr)
+DEF_HELPER_3(vfp_maxnmd, f64, f64, f64, ptr)
+DEF_HELPER_3(vfp_minnms, f32, f32, f32, ptr)
+DEF_HELPER_3(vfp_minnmd, f64, f64, f64, ptr)
 DEF_HELPER_1(vfp_negs, f32, f32)
 DEF_HELPER_1(vfp_negd, f64, f64)
 DEF_HELPER_1(vfp_abss, f32, f32)
Index: qemu-1.6.0+dfsg/target-arm/translate-a64.c
===================================================================
--- qemu-1.6.0+dfsg.orig/target-arm/translate-a64.c	2013-11-05 22:23:37.171379729 +0000
+++ qemu-1.6.0+dfsg/target-arm/translate-a64.c	2013-11-05 22:23:37.171379729 +0000
@@ -2123,6 +2123,18 @@
     case 0x3: /* FSUB */
         gen_helper_vfp_subd(tcg_res, tcg_op1, tcg_op2, fpst);
         break;
+    case 0x4: /* FMAX */
+	gen_helper_vfp_maxd(tcg_res, tcg_op1, tcg_op2, fpst);
+	break;
+    case 0x5: /* FMIN */
+	gen_helper_vfp_mind(tcg_res, tcg_op1, tcg_op2, fpst);
+	break;
+    case 0x6: /* FMAXNM */
+	gen_helper_vfp_maxnmd(tcg_res, tcg_op1, tcg_op2, fpst);
+	break;
+    case 0x7: /* FMINNM */
+	gen_helper_vfp_minnmd(tcg_res, tcg_op1, tcg_op2, fpst);
+	break;
     default:
         unallocated_encoding(s);
         return;
@@ -2175,6 +2187,18 @@
     case 0x3: /* FSUB */
         gen_helper_vfp_subs(tcg_res, tcg_op1, tcg_op2, fpst);
         break;
+    case 0x4: /* FMAX */
+	gen_helper_vfp_maxs(tcg_res, tcg_op1, tcg_op2, fpst);
+	break;
+    case 0x5: /* FMIN */
+	gen_helper_vfp_mins(tcg_res, tcg_op1, tcg_op2, fpst);
+	break;
+    case 0x6: /* FMAXNM */
+	gen_helper_vfp_maxnms(tcg_res, tcg_op1, tcg_op2, fpst);
+	break;
+    case 0x7: /* FMINNM */
+	gen_helper_vfp_minnms(tcg_res, tcg_op1, tcg_op2, fpst);
+	break;
     default:
         unallocated_encoding(s);
         return;
