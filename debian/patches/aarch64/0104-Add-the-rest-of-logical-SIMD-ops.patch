From 0e8731c7fffed216875b53e7ebfc95553fc00012 Mon Sep 17 00:00:00 2001
From: Michael Matz <matz@suse.de>
Date: Mon, 18 Mar 2013 04:42:15 +0100
Subject: [PATCH 104/169] Add the rest of logical SIMD ops.

That's AdvSIMD three-same, opcode 3, the missing ones were EOR, BSL,
BIT, BIF.
---
 target-arm/translate-a64.c | 82 ++++++++++++++++++++++++++++++++++++----------
 1 file changed, 64 insertions(+), 18 deletions(-)

Index: qemu-1.6.0+dfsg/target-arm/translate-a64.c
===================================================================
--- qemu-1.6.0+dfsg.orig/target-arm/translate-a64.c	2013-11-05 22:23:37.391379159 +0000
+++ qemu-1.6.0+dfsg/target-arm/translate-a64.c	2013-11-05 22:23:37.387379170 +0000
@@ -2387,7 +2387,7 @@
     tcg_temp_free_i64(tcg_res);
 }
 
-/* SIMD ORR */
+/* SIMD logical ops (three same, opcode 3) */
 static void handle_simdorr(DisasContext *s, uint32_t insn)
 {
     int rd = get_bits(insn, 0, 5);
@@ -2395,6 +2395,7 @@
     int rm = get_bits(insn, 16, 5);
     int size = get_bits(insn, 22, 2);
     int opcode = get_bits(insn, 11, 5);
+    bool is_u = get_bits(insn, 29, 1);
     bool is_q = get_bits(insn, 30, 1);
     int freg_offs_d = offsetof(CPUARMState, vfp.regs[rd * 2]);
     int freg_offs_n = offsetof(CPUARMState, vfp.regs[rn * 2]);
@@ -2406,33 +2407,79 @@
     TCGv_i64 tcg_res_1 = tcg_temp_new_i64();
     TCGv_i64 tcg_res_2 = tcg_temp_new_i64();
 
+    if (opcode != 0x3) {
+	unallocated_encoding(s);
+	return;
+    }
+
     tcg_gen_ld_i64(tcg_op1_1, cpu_env, freg_offs_n);
     tcg_gen_ld_i64(tcg_op2_1, cpu_env, freg_offs_m);
     if (is_q) {
         tcg_gen_ld_i64(tcg_op1_2, cpu_env, freg_offs_n + sizeof(float64));
         tcg_gen_ld_i64(tcg_op2_2, cpu_env, freg_offs_m + sizeof(float64));
-    } else {
-        tcg_gen_movi_i64(tcg_op1_2, 0);
-        tcg_gen_movi_i64(tcg_op2_2, 0);
     }
 
-    switch (opcode) {
-    case 0x3: /* ORR */
+    if (!is_u) {
+	/* AND, BIC, ORR, ORN */
         if (size & 1) {
             tcg_gen_not_i64(tcg_op2_1, tcg_op2_1);
-            tcg_gen_not_i64(tcg_op2_2, tcg_op2_2);
+	    if (is_q)
+	      tcg_gen_not_i64(tcg_op2_2, tcg_op2_2);
         }
         if (size & 2) {
             tcg_gen_or_i64(tcg_res_1, tcg_op1_1, tcg_op2_1);
-            tcg_gen_or_i64(tcg_res_2, tcg_op1_2, tcg_op2_2);
+	    if (is_q)
+	      tcg_gen_or_i64(tcg_res_2, tcg_op1_2, tcg_op2_2);
         } else {
             tcg_gen_and_i64(tcg_res_1, tcg_op1_1, tcg_op2_1);
-            tcg_gen_and_i64(tcg_res_2, tcg_op1_2, tcg_op2_2);
+	    if (is_q)
+	      tcg_gen_and_i64(tcg_res_2, tcg_op1_2, tcg_op2_2);
         }
-        break;
-    default:
-        unallocated_encoding(s);
-        return;
+    } else {
+	/* EOR, BSL, BIT, BIF */
+	switch (size) {
+	case 0: /* EOR */
+	    tcg_gen_xor_i64(tcg_res_1, tcg_op1_1, tcg_op2_1);
+	    if (is_q)
+	      tcg_gen_xor_i64(tcg_res_2, tcg_op1_2, tcg_op2_2);
+	    break;
+	case 1: /* BSL bitwise select */
+	    tcg_gen_ld_i64(tcg_res_1, cpu_env, freg_offs_d);
+	    tcg_gen_xor_i64(tcg_op1_1, tcg_op1_1, tcg_op2_1);
+	    tcg_gen_and_i64(tcg_op1_1, tcg_op1_1, tcg_res_1);
+	    tcg_gen_xor_i64(tcg_res_1, tcg_op2_1, tcg_op1_1);
+	    if (is_q) {
+		tcg_gen_ld_i64(tcg_res_2, cpu_env, freg_offs_d + sizeof(float64));
+		tcg_gen_xor_i64(tcg_op1_2, tcg_op1_2, tcg_op2_2);
+		tcg_gen_and_i64(tcg_op1_2, tcg_op1_2, tcg_res_2);
+		tcg_gen_xor_i64(tcg_res_2, tcg_op2_2, tcg_op1_2);
+	    }
+	    break;
+	case 2: /* BIT, bitwise insert if true */
+	    tcg_gen_ld_i64(tcg_res_1, cpu_env, freg_offs_d);
+	    tcg_gen_xor_i64(tcg_op1_1, tcg_op1_1, tcg_res_1);
+	    tcg_gen_and_i64(tcg_op1_1, tcg_op1_1, tcg_op2_1);
+	    tcg_gen_xor_i64(tcg_res_1, tcg_res_1, tcg_op1_1);
+	    if (is_q) {
+		tcg_gen_ld_i64(tcg_res_2, cpu_env, freg_offs_d + sizeof(float64));
+		tcg_gen_xor_i64(tcg_op1_2, tcg_op1_2, tcg_res_2);
+		tcg_gen_and_i64(tcg_op1_2, tcg_op1_2, tcg_op2_2);
+		tcg_gen_xor_i64(tcg_res_2, tcg_res_2, tcg_op1_2);
+	    }
+	    break;
+	case 3: /* BIF, bitwise insert if false */
+	    tcg_gen_ld_i64(tcg_res_1, cpu_env, freg_offs_d);
+	    tcg_gen_xor_i64(tcg_op1_1, tcg_op1_1, tcg_res_1);
+	    tcg_gen_andc_i64(tcg_op1_1, tcg_op1_1, tcg_op2_1);
+	    tcg_gen_xor_i64(tcg_res_1, tcg_res_1, tcg_op1_1);
+	    if (is_q) {
+		tcg_gen_ld_i64(tcg_res_2, cpu_env, freg_offs_d + sizeof(float64));
+		tcg_gen_xor_i64(tcg_op1_2, tcg_op1_2, tcg_res_2);
+		tcg_gen_andc_i64(tcg_op1_2, tcg_op1_2, tcg_op2_2);
+		tcg_gen_xor_i64(tcg_res_2, tcg_res_2, tcg_op1_2);
+	    }
+	    break;
+	}
     }
 
     tcg_gen_st_i64(tcg_res_1, cpu_env, freg_offs_d);
@@ -3191,13 +3238,12 @@
         } else if ((get_bits(insn, 29, 3) == 2) && !get_bits(insn, 21, 3) &&
             (get_bits(insn, 10, 6) == 0x7)) {
             handle_insg(s, insn);
-        } else if (!get_bits(insn, 31, 1) && !get_bits(insn, 29, 1) &&
-                   get_bits(insn, 21, 1) && get_bits(insn, 10, 1) &&
-                   (get_bits(insn, 11, 5) == 0x3)) {
-            handle_simdorr(s, insn);
         } else if (!get_bits(insn, 31, 1) && get_bits(insn, 21, 1) &&
                    get_bits(insn, 10, 1)) {
-            handle_simd3su0(s, insn);
+	    if (get_bits(insn, 11, 5) == 0x3)
+	      handle_simdorr(s, insn);
+	    else
+	      handle_simd3su0(s, insn);
 	} else if (!get_bits(insn, 31, 1) && get_bits(insn, 17, 5) == 0x18 &&
 		   get_bits(insn, 11, 1) && !get_bits(insn, 10, 1)) {
 	    handle_simd_accross(s, insn);
