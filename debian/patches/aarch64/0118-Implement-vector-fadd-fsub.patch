From ad3dbad2a01bc25deb8b9cedf1d7cff91cc0344e Mon Sep 17 00:00:00 2001
From: Michael Matz <matz@suse.de>
Date: Sun, 24 Mar 2013 07:26:47 +0100
Subject: [PATCH 118/169] Implement vector fadd/fsub

Needed by python, the single precision case mixes TCG variables,
but it does seem to work.
---
 target-arm/translate-a64.c | 47 ++++++++++++++++++++++++++++++++++++++++++++++
 1 file changed, 47 insertions(+)

Index: qemu-1.6.0+dfsg/target-arm/translate-a64.c
===================================================================
--- qemu-1.6.0+dfsg.orig/target-arm/translate-a64.c	2013-11-05 22:23:40.151372015 +0000
+++ qemu-1.6.0+dfsg/target-arm/translate-a64.c	2013-11-05 22:23:40.147372025 +0000
@@ -2615,6 +2615,9 @@
     int opcode = get_bits(insn, 11, 5);
     bool is_q = get_bits(insn, 30, 1);
     bool is_u = get_bits(insn, 29, 1);
+    bool is_pair = is_u;
+    bool is_float = false;
+    bool is_op2 = false;
     int freg_offs_d = offsetof(CPUARMState, vfp.regs[rd * 2]);
     int freg_offs_n = offsetof(CPUARMState, vfp.regs[rn * 2]);
     int freg_offs_m = offsetof(CPUARMState, vfp.regs[rm * 2]);
@@ -2624,6 +2627,22 @@
     int ebytes = (1 << size);
     int i;
 
+    switch (opcode) {
+	       /* base / pair  / sz&2 / sz&2 && pair */
+    case 0x1a: /* FADD / FADDP / FSUB / FABD */
+	is_float = true;
+	is_op2 = size & 2;
+	size = (size & 1) + 2;
+	ebytes = (1 << size);
+	is_u = true;
+	if (is_pair) {
+	    /* XXX Can't yet handle.  */
+	    unallocated_encoding(s);
+	    return;
+	}
+	break;
+    }
+
     for (i = 0; i < (is_q ? 16 : 8); i += ebytes) {
         simd_ld(tcg_op1, freg_offs_n + i, size, is_u);
         simd_ld(tcg_op2, freg_offs_m + i, size, is_u);
@@ -2671,6 +2690,34 @@
 	    tcg_gen_subi_i64 (tcg_res, tcg_res, 1);
 	    break;
 
+	case 0x1a: /* FADD / FADDP / FSUB / FABD */
+	    {
+	      TCGv_ptr fpst = get_fpstatus_ptr();
+
+	      if (size == 2) {
+		  tcg_gen_trunc_i64_i32(tcg_op1, tcg_op1);
+		  tcg_gen_trunc_i64_i32(tcg_op2, tcg_op2);
+	      }
+
+	      switch (is_op2 << 8 | opcode) {
+	      case 0x01a: /* FADD */
+		  if (size == 2)
+		    gen_helper_vfp_adds(tcg_res, tcg_op1, tcg_op2, fpst);
+		  else
+		    gen_helper_vfp_addd(tcg_res, tcg_op1, tcg_op2, fpst);
+		  break;
+	      case 0x110: /* FSUB */
+		  if (size == 2)
+		    gen_helper_vfp_subs(tcg_res, tcg_op1, tcg_op2, fpst);
+		  else
+		    gen_helper_vfp_subd(tcg_res, tcg_op1, tcg_op2, fpst);
+		  break;
+	      }
+
+	      tcg_temp_free_ptr(fpst);
+	      break;
+	    }
+
         default:
             unallocated_encoding(s);
             return;
