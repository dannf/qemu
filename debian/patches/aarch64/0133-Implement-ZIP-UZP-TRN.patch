From 2e7b2615e8f3e76fb3cb5367bff1a3987d641374 Mon Sep 17 00:00:00 2001
From: Michael Matz <matz@suse.de>
Date: Mon, 1 Apr 2013 01:25:15 +0200
Subject: [PATCH 133/169] Implement ZIP, UZP, TRN

This implements the shuffles in the AdvSIMD ZIP/UZP/TRN group.
(Only ZIP1 tested in the libpng15 testsuite).
---
 target-arm/translate-a64.c | 93 ++++++++++++++++++++++++++++++++++++++++++++--
 1 file changed, 90 insertions(+), 3 deletions(-)

Index: qemu-1.6.0+dfsg/target-arm/translate-a64.c
===================================================================
--- qemu-1.6.0+dfsg.orig/target-arm/translate-a64.c	2013-11-05 22:23:43.183364167 +0000
+++ qemu-1.6.0+dfsg/target-arm/translate-a64.c	2013-11-05 22:23:43.179364177 +0000
@@ -2833,6 +2833,82 @@
     tcg_temp_free_i64(tcg_res);
 }
 
+/* SIMD ZIP/UZP/TRN */
+static void handle_simd_zip(DisasContext *s, uint32_t insn)
+{
+    int rd = get_bits(insn, 0, 5);
+    int rn = get_bits(insn, 5, 5);
+    int rm = get_bits(insn, 16, 5);
+    int size = get_bits(insn, 22, 2);
+    int opcode = get_bits(insn, 12, 3);
+    bool is_q = get_bits(insn, 30, 1);
+    int freg_offs_d = offsetof(CPUARMState, vfp.regs[rd * 2]);
+    int freg_offs_n = offsetof(CPUARMState, vfp.regs[rn * 2]);
+    int freg_offs_m = offsetof(CPUARMState, vfp.regs[rm * 2]);
+    TCGv_i64 tcg_res = tcg_temp_new_i64();
+    int ebytes = (1 << size);
+    int i;
+    int datasize = is_q ? 16 : 8;
+    int elements = datasize / ebytes;
+    bool part = opcode & 4;
+
+    if (size == 3 && !is_q) {
+	unallocated_encoding(s);
+	return;
+    }
+
+    switch (opcode & 3) {
+    case 1: /* UZP1/2 */
+	for (i = 0; i < datasize; i += ebytes) {
+	    if (i < (datasize / 2))
+	      simd_ld(tcg_res,
+		      freg_offs_n + 2 * i + part * ebytes,
+		      size, false);
+	    else
+	      simd_ld(tcg_res,
+		      freg_offs_m + 2 * (i - datasize / 2) + part * ebytes,
+		      size, false);
+	    simd_st(tcg_res, freg_offs_d + i, size);
+	}
+	break;
+    case 2: /* TRN1/2 */
+	for (i = 0; i < elements; i++) {
+	    if (i & 1)
+	      simd_ld(tcg_res, freg_offs_m + ((i & ~1) + part) * ebytes,
+		      size, false);
+	    else
+	      simd_ld(tcg_res, freg_offs_n + ((i & ~1) + part) * ebytes,
+		      size, false);
+	    simd_st(tcg_res, freg_offs_d + i * ebytes, size);
+	}
+	break;
+    case 3: /* ZIP1/2 */
+	if (part) {
+	    freg_offs_n += sizeof(float64);
+	    freg_offs_m += sizeof(float64);
+	}
+	for (i = 0; i < elements; i++) {
+	    if (i & 1)
+	      simd_ld(tcg_res, freg_offs_m + (i >> 1) * ebytes, size, false);
+	    else
+	      simd_ld(tcg_res, freg_offs_n + (i >> 1) * ebytes, size, false);
+	    simd_st(tcg_res, freg_offs_d + i * ebytes, size);
+	}
+	break;
+    default:
+	unallocated_encoding(s);
+	return;
+    }
+
+    tcg_temp_free_i64(tcg_res);
+
+    if (!is_q) {
+        TCGv_i64 tcg_zero = tcg_const_i64(0);
+        simd_st(tcg_zero, freg_offs_d + sizeof(float64), 3);
+        tcg_temp_free_i64(tcg_zero);
+    }
+}
+
 static void handle_simd_accross(DisasContext *s, uint32_t insn)
 {
     int rd = get_bits(insn, 0, 5);
@@ -3545,9 +3621,8 @@
     case 0x0e:
 	if (get_bits(insn, 31, 1))
 	  goto unknown_insn;
-	if (!get_bits(insn, 21, 3)) {
-	    if (get_bits(insn, 15, 1) || !get_bits(insn, 10, 1))
-	      goto unknown_insn;
+	if (!get_bits(insn, 21, 3) && !get_bits(insn, 15, 1) &&
+	    get_bits(insn, 10, 1)) {
 	    /* AdvSIMD copy.  */
 	    if (get_bits(insn, 29, 2) == 3) /* INS element */
 	      handle_ins_elem(s, insn);
@@ -3581,6 +3656,18 @@
 	} else if (get_bits(insn, 17, 5) == 0x10 &&
 		   get_bits(insn, 11, 1) && !get_bits(insn, 10, 1)) {
 	    handle_simd_misc(s, insn);
+	} else if (!get_bits(insn, 21, 1) && !get_bits(insn, 15, 1) &&
+		   !get_bits(insn, 10, 1)) {
+	    if (get_bits(insn, 29, 1)) {
+		/* AdvSIMD EXT */
+		goto unknown_insn;
+	    } else if (get_bits (insn, 11, 1)) {
+		/* AdvSIMD ZIP/UZP/TRN */
+		handle_simd_zip(s, insn);
+	    } else {
+		/* AdvSIMD TBL/TBX */
+		goto unknown_insn;
+	    }
         } else {
             goto unknown_insn;
         }
