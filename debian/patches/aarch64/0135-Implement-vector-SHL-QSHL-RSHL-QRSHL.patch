From ab0c4291fe21733e97060ef671df02fcc2ba2209 Mon Sep 17 00:00:00 2001
From: Michael Matz <matz@suse.de>
Date: Mon, 1 Apr 2013 04:07:59 +0200
Subject: [PATCH 135/169] Implement vector SHL, QSHL, RSHL, QRSHL

This and the unsigned variants.  The nonsaturating rounding
helper in neon_helper (pre-existing) looks wrong, but for now
don't bother.
---
 target-arm/helper-a64.c    | 61 ++++++++++++++++++++++++++++++++++++++++++++++
 target-arm/helper.h        |  2 ++
 target-arm/translate-a64.c | 17 +++++++++++++
 3 files changed, 80 insertions(+)

Index: qemu-1.6.0+dfsg/target-arm/helper-a64.c
===================================================================
--- qemu-1.6.0+dfsg.orig/target-arm/helper-a64.c	2013-11-05 22:23:43.567363173 +0000
+++ qemu-1.6.0+dfsg/target-arm/helper-a64.c	2013-11-05 22:23:43.563363184 +0000
@@ -279,3 +279,64 @@
 
     set_float_rounding_mode(rmode, fp_status);
 }
+
+uint64_t HELPER(simd_op3s)(uint64_t op1, uint64_t op2, uint32_t insn)
+{
+    int size = get_bits(insn, 22, 2);
+    int opcode = get_bits(insn, 11, 5);
+    bool is_u = get_bits(insn, 29, 1);
+    /* The neon helpers < 64bit use i32 values, to which we simply
+       truncate per call.  */
+    switch ((opcode << 4) | (size << 1) | is_u) {
+    /* SSHL / USHL */
+    case 0x80: return helper_neon_shl_s8 (op1, op2);
+    case 0x81: return helper_neon_shl_u8 (op1, op2);
+    case 0x82: return helper_neon_shl_s16 (op1, op2);
+    case 0x83: return helper_neon_shl_u16 (op1, op2);
+    case 0x84: return helper_neon_shl_s32 (op1, op2);
+    case 0x85: return helper_neon_shl_u32 (op1, op2);
+    case 0x86: return helper_neon_shl_s64 (op1, op2);
+    case 0x87: return helper_neon_shl_u64 (op1, op2);
+
+    /* SRSHL / URSHL (rounding) */
+    case 0xa0: return helper_neon_rshl_s8 (op1, op2);
+    case 0xa1: return helper_neon_rshl_u8 (op1, op2);
+    case 0xa2: return helper_neon_rshl_s16 (op1, op2);
+    case 0xa3: return helper_neon_rshl_u16 (op1, op2);
+    case 0xa4: return helper_neon_rshl_s32 (op1, op2);
+    case 0xa5: return helper_neon_rshl_u32 (op1, op2);
+    case 0xa6: return helper_neon_rshl_s64 (op1, op2);
+    case 0xa7: return helper_neon_rshl_u64 (op1, op2);
+    default: return 0;
+    }
+}
+
+uint64_t HELPER(simd_op3s_env)(CPUARMState *env, uint64_t op1, uint64_t op2,
+			      uint32_t insn)
+{
+    int size = get_bits(insn, 22, 2);
+    int opcode = get_bits(insn, 11, 5);
+    bool is_u = get_bits(insn, 29, 1);
+    switch ((opcode << 4) | (size << 1) | is_u) {
+    /* SQSHL / UQSHL (saturating) */
+    case 0x90: return helper_neon_qshl_s8 (env, op1, op2);
+    case 0x91: return helper_neon_qshl_u8 (env, op1, op2);
+    case 0x92: return helper_neon_qshl_s16 (env, op1, op2);
+    case 0x93: return helper_neon_qshl_u16 (env, op1, op2);
+    case 0x94: return helper_neon_qshl_s32 (env, op1, op2);
+    case 0x95: return helper_neon_qshl_u32 (env, op1, op2);
+    case 0x96: return helper_neon_qshl_s64 (env, op1, op2);
+    case 0x97: return helper_neon_qshl_u64 (env, op1, op2);
+
+    /* SQRSHL / UQRSHL (sat + round) */
+    case 0xb0: return helper_neon_qrshl_s8 (env, op1, op2);
+    case 0xb1: return helper_neon_qrshl_u8 (env, op1, op2);
+    case 0xb2: return helper_neon_qrshl_s16 (env, op1, op2);
+    case 0xb3: return helper_neon_qrshl_u16 (env, op1, op2);
+    case 0xb4: return helper_neon_qrshl_s32 (env, op1, op2);
+    case 0xb5: return helper_neon_qrshl_u32 (env, op1, op2);
+    case 0xb6: return helper_neon_qrshl_s64 (env, op1, op2);
+    case 0xb7: return helper_neon_qrshl_u64 (env, op1, op2);
+    default: return 0;
+    }
+}
Index: qemu-1.6.0+dfsg/target-arm/helper.h
===================================================================
--- qemu-1.6.0+dfsg.orig/target-arm/helper.h	2013-11-05 22:23:43.567363173 +0000
+++ qemu-1.6.0+dfsg/target-arm/helper.h	2013-11-05 22:23:43.563363184 +0000
@@ -496,6 +496,8 @@
 DEF_HELPER_FLAGS_1(clz64, TCG_CALL_NO_RWG_SE, i64, i64)
 DEF_HELPER_FLAGS_2(rintd, TCG_CALL_NO_RWG_SE, f64, f64, ptr)
 DEF_HELPER_FLAGS_2(rints, TCG_CALL_NO_RWG_SE, f32, f32, ptr)
+DEF_HELPER_FLAGS_3(simd_op3s, TCG_CALL_NO_RWG_SE, i64, i64, i64, i32)
+DEF_HELPER_4(simd_op3s_env, i64, env, i64, i64, i32)
 DEF_HELPER_1(tb_flush, void, env)
 DEF_HELPER_2(set_rmode, void, i32, ptr)
 
Index: qemu-1.6.0+dfsg/target-arm/translate-a64.c
===================================================================
--- qemu-1.6.0+dfsg.orig/target-arm/translate-a64.c	2013-11-05 22:23:43.567363173 +0000
+++ qemu-1.6.0+dfsg/target-arm/translate-a64.c	2013-11-05 22:23:43.567363173 +0000
@@ -2814,6 +2814,23 @@
 	      break;
 	    }
 
+	case 0x08: /* SSHL / USHL */
+	case 0x09: /* SQSHL / UQSHL (saturating) */
+	case 0x0a: /* SRSHL / URSHL (rounding) */
+	case 0x0b: /* SQRSHL / UQRSHL (sat + round) */
+	    {
+	      /* The neon helpers expect 32bit TCGv's for sizes < 64.  */
+	      TCGv_i32 insncode = tcg_const_i32(insn);
+	      /* The saturating ones might set the QC flag in fpcsr,
+	         so need the environment.  */
+	      if (opcode & 1)
+		gen_helper_simd_op3s_env(tcg_res, cpu_env, tcg_op1,
+					 tcg_op2, insncode);
+	      else
+		gen_helper_simd_op3s(tcg_res, tcg_op1, tcg_op2, insncode);
+	    }
+	    break;
+
         default:
             unallocated_encoding(s);
             return;
