From 6616eb7553c1799dbe0986f2b2f11867a8f81876 Mon Sep 17 00:00:00 2001
From: Michael Matz <matz@suse.de>
Date: Fri, 10 May 2013 17:09:57 +0200
Subject: [PATCH 160/169] linux-user: Implement interrupting syscalls

When a syscall waits for something a signal handler is supposed
to do (e.g. reading from a pipe to be written when SIGCHLD arrives),
and that signal arrives during a restarting syscall (or between
checking for presence of signals and doing the host syscall) then
the target signal handler won't be run.  We use longjmp to
leave the critical section, deliver the signal and restart the
syscall.
---
 linux-user/main.c    | 32 +++++++++------------
 linux-user/qemu.h    |  1 +
 linux-user/signal.c  | 12 +++++++-
 linux-user/syscall.c | 81 ++++++++++++++++++++++++++++++++++------------------
 4 files changed, 78 insertions(+), 48 deletions(-)

Index: qemu-1.6.0+dfsg/linux-user/main.c
===================================================================
--- qemu-1.6.0+dfsg.orig/linux-user/main.c	2013-11-05 22:23:48.627350076 +0000
+++ qemu-1.6.0+dfsg/linux-user/main.c	2013-11-05 22:23:48.619350097 +0000
@@ -880,25 +880,19 @@
         case EXCP_BKPT:
             {
 #ifdef TARGET_ARM64
-	        TaskState *ts = ((CPUArchState*)env)->opaque;
-	        target_ulong r;
-		target_ulong callid = env->xregs[8];
-                r = do_syscall(env,
-			       env->xregs[8],
-			       env->xregs[0],
-			       env->xregs[1],
-			       env->xregs[2],
-			       env->xregs[3],
-			       env->xregs[4],
-			       env->xregs[5],
-			       0, 0);
-		if ((r == -EINTR) && ts->signal_restart &&
-		    syscall_restartable(callid)) {
-		    env->pc -= 4;
-		} else {
-		    env->xregs[0] = r;
-		}
-		ts->signal_restart = 0;
+	        target_ulong r = do_syscall(env,
+                                           env->xregs[8],
+                                           env->xregs[0],
+                                           env->xregs[1],
+                                           env->xregs[2],
+                                           env->xregs[3],
+                                           env->xregs[4],
+                                           env->xregs[5],
+                                           0, 0);
+		if (r == -TARGET_ERESTART)
+		  env->pc -= 4;
+		else
+		  env->xregs[0] = r;
 #else
 
                 env->eabi = 1;
Index: qemu-1.6.0+dfsg/linux-user/qemu.h
===================================================================
--- qemu-1.6.0+dfsg.orig/linux-user/qemu.h	2013-11-05 22:23:48.627350076 +0000
+++ qemu-1.6.0+dfsg/linux-user/qemu.h	2013-11-05 22:23:48.619350097 +0000
@@ -130,6 +130,7 @@
     struct emulated_sigtable sigtab[TARGET_NSIG];
     struct sigqueue sigqueue_table[MAX_SIGQUEUE_SIZE]; /* siginfo queue */
     struct sigqueue *first_free; /* first free siginfo queue entry */
+    sigjmp_buf signal_buf;
     int signal_pending; /* non zero if a signal may be pending */
     int signal_in_syscall; /* non zero if we are in do_syscall() */
     int signal_restart; /* non zero if we need to restart a syscall */
Index: qemu-1.6.0+dfsg/linux-user/signal.c
===================================================================
--- qemu-1.6.0+dfsg.orig/linux-user/signal.c	2013-11-05 22:23:48.627350076 +0000
+++ qemu-1.6.0+dfsg/linux-user/signal.c	2013-11-05 22:23:48.619350097 +0000
@@ -25,6 +25,7 @@
 #include <assert.h>
 #include <sys/ucontext.h>
 #include <sys/resource.h>
+#include <sys/syscall.h>
 #include <sched.h>
 
 #include "qemu.h"
@@ -537,8 +538,17 @@
 #endif
     host_to_target_siginfo_noswap(&tinfo, info);
     if (queue_signal(env, sig, &tinfo) == 1) {
+	TaskState *ts = env->opaque;
         /* interrupt the virtual CPU as soon as possible */
         cpu_exit(thread_cpu);
+	if (ts->signal_in_syscall) {
+	    /* If we're signalled during a syscall, make really
+	       sure we're leaving that one, it might be blocking,
+	       waiting for something the handler for this signal
+	       does, so we need to deliver it before restarting
+	       the syscall.  */
+	    siglongjmp(ts->signal_buf, 1);
+	}
     }
 }
 
@@ -644,7 +654,7 @@
         if (host_sig != SIGSEGV && host_sig != SIGBUS) {
             sigfillset(&act1.sa_mask);
             act1.sa_flags = SA_SIGINFO;
-#if defined(TARGET_ARM) || defined(TARGET_ARM64)
+#if 0 && defined(TARGET_ARM)
             /* Breaks boehm-gc, we have to do this manually */
             /*
              * Unfortunately our hacks only work as long as we don't do parallel
Index: qemu-1.6.0+dfsg/linux-user/syscall.c
===================================================================
--- qemu-1.6.0+dfsg.orig/linux-user/syscall.c	2013-11-05 22:23:48.627350076 +0000
+++ qemu-1.6.0+dfsg/linux-user/syscall.c	2013-11-05 22:23:48.623350087 +0000
@@ -248,6 +248,24 @@
 _syscall4(int, reboot, int, magic1, int, magic2, unsigned int, cmd,
           void *, arg);
 
+#define wrap_restart(X) \
+({ \
+  TaskState *ts = ((CPUArchState*)thread_cpu->env_ptr)->opaque; \
+  abi_long __ret; \
+  if (sigsetjmp(ts->signal_buf, 1) != 0) \
+    __ret = -TARGET_ERESTART; \
+  else { \
+    ts->signal_in_syscall = 1; \
+    if (ts->signal_pending) \
+      __ret = -TARGET_ERESTART; \
+    else { \
+      __ret = (X); \
+    } \
+  } \
+  ts->signal_in_syscall = 0; \
+  __ret; \
+})
+
 static bitmask_transtbl fcntl_flags_tbl[] = {
   { TARGET_O_ACCMODE,   TARGET_O_WRONLY,    O_ACCMODE,   O_WRONLY,    },
   { TARGET_O_ACCMODE,   TARGET_O_RDWR,      O_ACCMODE,   O_RDWR,      },
@@ -994,7 +1012,8 @@
         tv_ptr = NULL;
     }
 
-    ret = get_errno(select(n, rfds_ptr, wfds_ptr, efds_ptr, tv_ptr));
+    /*sleep(10);*/
+    ret = wrap_restart(get_errno(select(n, rfds_ptr, wfds_ptr, efds_ptr, tv_ptr)));
 
     if (!is_error(ret)) {
         if (rfd_addr && copy_to_user_fdset(rfd_addr, &rfds, n))
@@ -1834,9 +1853,9 @@
     if (send) {
         ret = target_to_host_cmsg(&msg, msgp);
         if (ret == 0)
-            ret = get_errno(sendmsg(fd, &msg, flags));
+            ret = wrap_restart(get_errno(sendmsg(fd, &msg, flags)));
     } else {
-        ret = get_errno(recvmsg(fd, &msg, flags));
+        ret = wrap_restart(get_errno(recvmsg(fd, &msg, flags)));
         if (!is_error(ret)) {
             len = ret;
             ret = host_to_target_cmsg(msgp, &msg);
@@ -2007,9 +2026,9 @@
             unlock_user(host_msg, msg, 0);
             return ret;
         }
-        ret = get_errno(sendto(fd, host_msg, len, flags, addr, addrlen));
+        ret = wrap_restart(get_errno(sendto(fd, host_msg, len, flags, addr, addrlen)));
     } else {
-        ret = get_errno(send(fd, host_msg, len, flags));
+        ret = wrap_restart(get_errno(send(fd, host_msg, len, flags)));
     }
     unlock_user(host_msg, msg, 0);
     return ret;
@@ -2038,10 +2057,10 @@
             goto fail;
         }
         addr = alloca(addrlen);
-        ret = get_errno(recvfrom(fd, host_msg, len, flags, addr, &addrlen));
+        ret = wrap_restart(get_errno(recvfrom(fd, host_msg, len, flags, addr, &addrlen)));
     } else {
         addr = NULL; /* To keep compiler quiet.  */
-        ret = get_errno(qemu_recv(fd, host_msg, len, flags));
+        ret = wrap_restart(get_errno(qemu_recv(fd, host_msg, len, flags)));
     }
     if (!is_error(ret)) {
         if (target_addr) {
@@ -4892,8 +4911,8 @@
         } else {
             pts = NULL;
         }
-        return get_errno(sys_futex(g2h(uaddr), op, tswap32(val),
-                         pts, NULL, val3));
+        return wrap_restart(get_errno(sys_futex(g2h(uaddr), op, tswap32(val),
+                         pts, NULL, val3)));
     case FUTEX_WAKE:
         return get_errno(sys_futex(g2h(uaddr), op, tswap32(val), NULL, NULL, 0));
     case FUTEX_FD:
@@ -5382,11 +5401,6 @@
     void *p;
     TaskState *ts = ((CPUArchState*)cpu_env)->opaque;
 
-    if (!ts->signal_restart) {
-        /* remember syscall info for restart */
-        ts->signal_in_syscall = 1;
-    }
-
 #ifdef DEBUG
     gemu_log("syscall %d", num);
 #endif
@@ -5445,14 +5459,14 @@
         else {
             if (!(p = lock_user(VERIFY_WRITE, arg2, arg3, 0)))
                 goto efault;
-            ret = get_errno(read(arg1, p, arg3));
+            ret = wrap_restart(get_errno(read(arg1, p, arg3)));
             unlock_user(p, arg2, ret);
         }
         break;
     case TARGET_NR_write:
         if (!(p = lock_user(VERIFY_READ, arg2, arg3, 1)))
             goto efault;
-        ret = get_errno(write(arg1, p, arg3));
+        ret = wrap_restart(get_errno(write(arg1, p, arg3)));
         unlock_user(p, arg2, 0);
         break;
     case TARGET_NR_open:
@@ -5488,7 +5502,7 @@
     case TARGET_NR_waitpid:
         {
             int status;
-            ret = get_errno(waitpid(arg1, &status, arg3));
+            ret = wrap_restart(get_errno(waitpid(arg1, &status, arg3)));
             if (!is_error(ret) && arg2 && ret
                 && put_user_s32(host_to_target_waitstatus(status), arg2))
                 goto efault;
@@ -5500,7 +5514,7 @@
         {
             siginfo_t info;
             info.si_pid = 0;
-            ret = get_errno(waitid(arg1, arg2, &info, arg4));
+            ret = wrap_restart(get_errno(waitid(arg1, arg2, &info, arg4)));
             if (!is_error(ret) && arg3 && info.si_pid != 0) {
                 if (!(p = lock_user(VERIFY_WRITE, arg3, sizeof(target_siginfo_t), 0)))
                     goto efault;
@@ -6337,6 +6351,7 @@
             target_to_host_old_sigset(&set, p);
             unlock_user(p, arg1, 0);
 #endif
+	    /* Don't wrap_restart this one.  */
             ret = get_errno(sigsuspend(&set));
         }
         break;
@@ -6348,6 +6363,7 @@
                 goto efault;
             target_to_host_sigset(&set, p);
             unlock_user(p, arg1, 0);
+	    /* Don't wrap_restart this one.  */
             ret = get_errno(sigsuspend(&set));
         }
         break;
@@ -6570,8 +6586,9 @@
                 sig_ptr = NULL;
             }
 
-            ret = get_errno(sys_pselect6(n, rfds_ptr, wfds_ptr, efds_ptr,
-                                         ts_ptr, sig_ptr));
+	    /*sleep(10);*/
+            ret = wrap_restart(get_errno(sys_pselect6(n, rfds_ptr, wfds_ptr, efds_ptr,
+                                         ts_ptr, sig_ptr)));
 
             if (!is_error(ret)) {
                 if (rfd_addr && copy_to_user_fdset(rfd_addr, &rfds, n))
@@ -7099,7 +7116,7 @@
                 rusage_ptr = &rusage;
             else
                 rusage_ptr = NULL;
-            ret = get_errno(wait4(arg1, &status, arg3, rusage_ptr));
+            ret = wrap_restart(get_errno(wait4(arg1, &status, arg3, rusage_ptr)));
             if (!is_error(ret)) {
                 if (status_ptr && ret) {
                     status = host_to_target_waitstatus(status);
@@ -7544,7 +7561,7 @@
                     set = NULL;
                 }
 
-                ret = get_errno(sys_ppoll(pfd, nfds, timeout_ts, set, _NSIG/8));
+                ret = wrap_restart(get_errno(sys_ppoll(pfd, nfds, timeout_ts, set, _NSIG/8)));
 
                 if (!is_error(ret) && arg3) {
                     host_to_target_timespec(arg3, timeout_ts);
@@ -7554,7 +7571,7 @@
                 }
             } else
 # endif
-                ret = get_errno(poll(pfd, nfds, timeout));
+                ret = wrap_restart(get_errno(poll(pfd, nfds, timeout)));
 
             if (!is_error(ret)) {
                 for(i = 0; i < nfds; i++) {
@@ -7575,7 +7592,9 @@
         {
             struct iovec *vec = lock_iovec(VERIFY_WRITE, arg2, arg3, 0);
             if (vec != NULL) {
-                ret = get_errno(readv(arg1, vec, arg3));
+		/* XXX might be implemented as loop in libc, hence
+		   no syscall, in which case we don't want to wrap it.  */
+                ret = wrap_restart(get_errno(readv(arg1, vec, arg3)));
                 unlock_iovec(vec, arg2, arg3, 1);
             } else {
                 ret = -host_to_target_errno(errno);
@@ -7790,7 +7809,8 @@
         }
         if (!(p = lock_user(VERIFY_WRITE, arg2, arg3, 0)))
             goto efault;
-        ret = get_errno(pread64(arg1, p, arg3, target_offset64(arg4, arg5)));
+	/* XXX might be just a libc wrapper, no wrapping then.  */
+        ret = wrap_restart(get_errno(pread64(arg1, p, arg3, target_offset64(arg4, arg5))));
         unlock_user(p, arg2, ret);
         break;
     case TARGET_NR_pwrite64:
@@ -9302,13 +9322,13 @@
                 set = NULL;
             }
 
-            ret = get_errno(epoll_pwait(epfd, ep, maxevents, timeout, set));
+            ret = wrap_restart(get_errno(epoll_pwait(epfd, ep, maxevents, timeout, set)));
             break;
         }
 #endif
 #if defined(TARGET_NR_epoll_wait)
         case TARGET_NR_epoll_wait:
-            ret = get_errno(epoll_wait(epfd, ep, maxevents, timeout));
+            ret = wrap_restart(get_errno(epoll_wait(epfd, ep, maxevents, timeout)));
             break;
 #endif
         default:
@@ -9377,12 +9397,17 @@
         break;
     }
 fail:
+    if (ts->signal_restart) {
+	ts->signal_restart = 0;
+	if (ret == -TARGET_EINTR)
+	  ret = -TARGET_ERESTART;
+    }
+
 #ifdef DEBUG
     gemu_log(" = " TARGET_ABI_FMT_ld "\n", ret);
 #endif
     if(do_strace)
         print_syscall_ret(num, ret);
-    ts->signal_in_syscall = 0;
     return ret;
 efault:
     ret = -TARGET_EFAULT;
