From ad4607b4bf4c6bb2251c332afd6e1b27327f087a Mon Sep 17 00:00:00 2001
From: Alexander Graf <agraf@suse.de>
Date: Fri, 16 Aug 2013 11:09:43 +0200
Subject: [PATCH 161/169] linux-user: Implement sendmmsg syscall

Glibc when built for newer kernels assumes that the sendmmsg syscall is available.
Without it, dns resolution simply fails to work.

Wrap the syscall with existing infrastructure so that we don't have a host dependency
on sendmmsg.

Signed-off-by: Alexander Graf <agraf@suse.de>
---
 linux-user/syscall.c      | 29 +++++++++++++++++++++++++++++
 linux-user/syscall_defs.h |  4 ++++
 2 files changed, 33 insertions(+)

Index: qemu-1.6.0+dfsg/linux-user/syscall.c
===================================================================
--- qemu-1.6.0+dfsg.orig/linux-user/syscall.c	2013-11-05 22:23:48.859349476 +0000
+++ qemu-1.6.0+dfsg/linux-user/syscall.c	2013-11-05 22:23:48.859349476 +0000
@@ -1881,6 +1881,30 @@
     return ret;
 }
 
+#ifdef TARGET_NR_sendmmsg
+static abi_long do_sendmmsg(int fd, abi_ulong target_msgvec,
+                            unsigned int vlen, unsigned int flags)
+{
+    struct target_mmsghdr *mmsgp;
+    abi_ulong arg2 = target_msgvec;
+    int i;
+
+    if (!(mmsgp = lock_user(VERIFY_WRITE, target_msgvec,
+                            sizeof(*mmsgp) * vlen, 1))) {
+        return -TARGET_EFAULT;
+    }
+
+    for (i = 0; i < vlen; i++) {
+        mmsgp[i].msg_len = tswap32(do_sendrecvmsg(fd, arg2, flags, 1));
+        arg2 += sizeof(struct target_mmsghdr);
+    }
+
+    unlock_user(mmsgp, target_msgvec, 0);
+    /* XXX need to handle nonblocking case too */
+    return vlen;
+}
+#endif
+
 /* If we don't have a system accept4() then just call accept.
  * The callsites to do_accept4() will ensure that they don't
  * pass a non-zero flags argument in this config.
@@ -6976,6 +7000,11 @@
         ret = do_sendrecvmsg(arg1, arg2, arg3, 1);
         break;
 #endif
+#ifdef TARGET_NR_sendmmsg
+    case TARGET_NR_sendmmsg:
+        ret = do_sendmmsg(arg1, arg2, arg3, arg4);
+        break;
+#endif
 #ifdef TARGET_NR_sendto
     case TARGET_NR_sendto:
         ret = do_sendto(arg1, arg2, arg3, arg4, arg5, arg6);
Index: qemu-1.6.0+dfsg/linux-user/syscall_defs.h
===================================================================
--- qemu-1.6.0+dfsg.orig/linux-user/syscall_defs.h	2013-11-05 22:23:48.859349476 +0000
+++ qemu-1.6.0+dfsg/linux-user/syscall_defs.h	2013-11-05 22:23:48.859349476 +0000
@@ -222,6 +222,10 @@
   return __cmsg;
 }
 
+struct target_mmsghdr {
+    struct target_msghdr msg_hdr;              /* Message header */
+    unsigned int         msg_len;              /* Number of bytes transmitted */
+};
 
 struct  target_rusage {
         struct target_timeval ru_utime;        /* user time used */
