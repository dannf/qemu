From e14c1a563a83aa5418386e3bd4071e023f2eaafc Mon Sep 17 00:00:00 2001
From: Andreas Schwab <schwab@suse.de>
Date: Mon, 23 Sep 2013 12:50:07 +0200
Subject: [PATCH 164/169] softfloat: correctly handle overflow in float[32|64]
 to uint64 conversion

We need to return UINT64_MAX instead of INT64_MAX, which is what the
float[32|64] to int64 conversion returns.

Signed-off-by: Andreas Schwab <schwab@suse.de>
---
 fpu/softfloat.c | 12 ++++++++++++
 1 file changed, 12 insertions(+)

Index: qemu-1.6.0+dfsg/fpu/softfloat.c
===================================================================
--- qemu-1.6.0+dfsg.orig/fpu/softfloat.c	2013-11-05 22:23:49.503347809 +0000
+++ qemu-1.6.0+dfsg/fpu/softfloat.c	2013-11-05 22:23:49.499347820 +0000
@@ -6525,6 +6525,9 @@
     if (aSign) {
 	res = 0;
 	float_raise(float_flag_invalid STATUS_VAR);
+    } else if (aExp > 0xbe) {
+        res = 0xffffffffffffffffULL;
+        float_raise(float_flag_invalid STATUS_VAR);
     } else {
 	/* If a > 2^63 (but < 2^64) it won't fit into a signed int,
 	   so half the value, convert to int, and double it again.  */
@@ -6551,6 +6554,9 @@
     if (aSign) {
 	res = 0;
 	float_raise(float_flag_invalid STATUS_VAR);
+    } else if (aExp > 0xbe) {
+        res = 0xffffffffffffffffULL;
+        float_raise(float_flag_invalid STATUS_VAR);
     } else {
 	/* If a > 2^63 (but < 2^64) it won't fit into a signed int,
 	   so half the value, convert to int, and double it again.  */
@@ -6649,6 +6655,9 @@
     if (aSign) {
 	res = 0;
 	float_raise( float_flag_invalid STATUS_VAR);
+    } else if (aExp > 0x43e) {
+        res = 0xffffffffffffffffULL;
+        float_raise(float_flag_invalid STATUS_VAR);
     } else {
 	/* If a > 2^63 (but < 2^64) it won't fit into a signed int,
 	   so half the value, convert to int, and double it again.  */
@@ -6675,6 +6684,9 @@
     if (aSign) {
 	res = 0;
 	float_raise( float_flag_invalid STATUS_VAR);
+    } else if (aExp > 0x43e) {
+        res = 0xffffffffffffffffULL;
+        float_raise(float_flag_invalid STATUS_VAR);
     } else {
 	/* If a > 2^63 (but < 2^64) it won't fit into a signed int,
 	   so half the value, convert to int, and double it again.  */
