From e50f9d3925e1d0ebb052cfef2afd2b5244c79621 Mon Sep 17 00:00:00 2001
From: Michael Matz <matz@suse.de>
Date: Wed, 9 Oct 2013 15:10:56 +0200
Subject: [PATCH 165/169] linux-user: Don't wrap wait4

This points to a general problem with the siglongjmp approach
to exit the signal handler.  If the syscall already returned to
userspace, but the flag is still set (small but possible window),
we loose the return value of the syscall as we restart it.
For wait() it's worse, we loose the fact that there were childs
at all (the syscall returned the pid of one of them), and restarting
the wait() can exit with ECHILD.  Paper over the problem for wait.
---
 linux-user/syscall.c | 6 +++---
 1 file changed, 3 insertions(+), 3 deletions(-)

Index: qemu-1.6.0+dfsg/linux-user/syscall.c
===================================================================
--- qemu-1.6.0+dfsg.orig/linux-user/syscall.c	2013-11-05 22:23:49.703347290 +0000
+++ qemu-1.6.0+dfsg/linux-user/syscall.c	2013-11-05 22:23:49.695347312 +0000
@@ -5526,7 +5526,7 @@
     case TARGET_NR_waitpid:
         {
             int status;
-            ret = wrap_restart(get_errno(waitpid(arg1, &status, arg3)));
+            ret = get_errno(waitpid(arg1, &status, arg3));
             if (!is_error(ret) && arg2 && ret
                 && put_user_s32(host_to_target_waitstatus(status), arg2))
                 goto efault;
@@ -5538,7 +5538,7 @@
         {
             siginfo_t info;
             info.si_pid = 0;
-            ret = wrap_restart(get_errno(waitid(arg1, arg2, &info, arg4)));
+            ret = get_errno(waitid(arg1, arg2, &info, arg4));
             if (!is_error(ret) && arg3 && info.si_pid != 0) {
                 if (!(p = lock_user(VERIFY_WRITE, arg3, sizeof(target_siginfo_t), 0)))
                     goto efault;
@@ -7145,7 +7145,7 @@
                 rusage_ptr = &rusage;
             else
                 rusage_ptr = NULL;
-            ret = wrap_restart(get_errno(wait4(arg1, &status, arg3, rusage_ptr)));
+            ret = get_errno(wait4(arg1, &status, arg3, rusage_ptr));
             if (!is_error(ret)) {
                 if (status_ptr && ret) {
                     status = host_to_target_waitstatus(status);
