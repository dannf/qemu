From 8d52e9c6b1541f5a57303864fcec1fffaef3a928 Mon Sep 17 00:00:00 2001
From: Michael Matz <matz@suse.de>
Date: Fri, 11 Oct 2013 18:53:55 +0200
Subject: [PATCH 169/169] linux-user: Disable interrupting syscalls

The approach with longjmp doesn't work, the signal might arrive
just after the syscall successfully returned, but before the flag
is reset, which would make use restart the syscall, even though
it wasn't really interrupted.  Disable this for now, needs
more redesign, probably a watchdog thread.

Signed-off-by: Michael Matz <matz@suse.de>
---
 linux-user/signal.c | 8 ++++++--
 1 file changed, 6 insertions(+), 2 deletions(-)

Index: qemu-1.6.0+dfsg/linux-user/signal.c
===================================================================
--- qemu-1.6.0+dfsg.orig/linux-user/signal.c	2013-11-05 22:23:50.491345252 +0000
+++ qemu-1.6.0+dfsg/linux-user/signal.c	2013-11-05 22:23:50.487345262 +0000
@@ -541,6 +541,9 @@
 	TaskState *ts = env->opaque;
         /* interrupt the virtual CPU as soon as possible */
         cpu_exit(thread_cpu);
+#if 0
+	/* This doesn't really work.  We can loose return values
+	   from the syscall we try to break here.  */
 	if (ts->signal_in_syscall) {
 	    /* If we're signalled during a syscall, make really
 	       sure we're leaving that one, it might be blocking,
@@ -549,6 +552,7 @@
 	       the syscall.  */
 	    siglongjmp(ts->signal_buf, 1);
 	}
+#endif
     }
 }
 
@@ -665,8 +669,8 @@
             if ((k->sa_flags & TARGET_SA_RESTART) && host_sig == SIGPWR)
 		pin_to_one_cpu ();
 #else
-            if (k->sa_flags & TARGET_SA_RESTART)
-                act1.sa_flags |= SA_RESTART;
+            /*if (k->sa_flags & TARGET_SA_RESTART)
+                act1.sa_flags |= SA_RESTART;*/
 #endif
             /* NOTE: it is important to update the host kernel signal
                ignore state to avoid getting unexpected interrupted
